{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Beanie - is an Asynchronous Python object-document mapper (ODM) for MongoDB, based on Motor and Pydantic . When using Beanie each database collection has a corresponding Document that is used to interact with that collection. In addition to retrieving data, Beanie allows you to add, update, or delete documents from the collection as well. Beanie saves you time by removing boiler-plate code and it helps you focus on the parts of your app that actually matter. Data and schema migrations are supported by Beanie out of the box. Installation PIP pip install beanie Poetry poetry add beanie Example from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed , init_beanie import asyncio , motor class Category ( BaseModel ): name : str description : str class Product ( Document ): name : str # You can use normal types just like in pydantic description : Optional [ str ] = None price : Indexed ( float ) # You can also specify that a field should correspond to an index category : Category # You can include pydantic models as well # Beanie is fully asynchronous, so we will access it from an async function async def example (): # Beanie uses Motor under the hood client = motor . motor_asyncio . AsyncIOMotorClient ( \"mongodb://user:pass@host:27017\" ) # Init beanie with the Product document class await init_beanie ( database = client . db_name , document_models = [ Product ]) chocolate = Category ( name = \"Chocolate\" , description = \"A preparation of roasted and ground cacao seeds.\" ) # Beanie documents work just like pydantic models tonybar = Product ( name = \"Tony's\" , price = 5.95 , category = chocolate ) # And can be inserted into the database await tonybar . insert () # You can find documents with pythonic syntax product = await Product . find_one ( Product . price < 10 ) # And update them await product . set ({ Product . name : \"Gold bar\" }) asyncio . run ( example ()) Links Documentation Doc - Tutorial, API docmentation, and development guidlines. Example Projects fastapi-cosmos-beanie - FastAPI + Beanie ODM + Azure Cosmos Demo Application by Anthony Shaw fastapi-beanie-jwt - Sample FastAPI server with JWT auth and Beanie ODM by Michael duPont Articles Announcing Beanie - MongoDB ODM Build a Cocktail API with Beanie and MongoDB MongoDB indexes with Beanie Beanie Projections. Reducing network and database load. Resources GitHub - GitHub page of the project Changelog - list of all the valuable changes Discord - ask your questions, share ideas or just say Hello!! Supported by JetBrains","title":"Overview"},{"location":"#overview","text":"Beanie - is an Asynchronous Python object-document mapper (ODM) for MongoDB, based on Motor and Pydantic . When using Beanie each database collection has a corresponding Document that is used to interact with that collection. In addition to retrieving data, Beanie allows you to add, update, or delete documents from the collection as well. Beanie saves you time by removing boiler-plate code and it helps you focus on the parts of your app that actually matter. Data and schema migrations are supported by Beanie out of the box.","title":"Overview"},{"location":"#installation","text":"","title":"Installation"},{"location":"#pip","text":"pip install beanie","title":"PIP"},{"location":"#poetry","text":"poetry add beanie","title":"Poetry"},{"location":"#example","text":"from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed , init_beanie import asyncio , motor class Category ( BaseModel ): name : str description : str class Product ( Document ): name : str # You can use normal types just like in pydantic description : Optional [ str ] = None price : Indexed ( float ) # You can also specify that a field should correspond to an index category : Category # You can include pydantic models as well # Beanie is fully asynchronous, so we will access it from an async function async def example (): # Beanie uses Motor under the hood client = motor . motor_asyncio . AsyncIOMotorClient ( \"mongodb://user:pass@host:27017\" ) # Init beanie with the Product document class await init_beanie ( database = client . db_name , document_models = [ Product ]) chocolate = Category ( name = \"Chocolate\" , description = \"A preparation of roasted and ground cacao seeds.\" ) # Beanie documents work just like pydantic models tonybar = Product ( name = \"Tony's\" , price = 5.95 , category = chocolate ) # And can be inserted into the database await tonybar . insert () # You can find documents with pythonic syntax product = await Product . find_one ( Product . price < 10 ) # And update them await product . set ({ Product . name : \"Gold bar\" }) asyncio . run ( example ())","title":"Example"},{"location":"#links","text":"","title":"Links"},{"location":"#documentation","text":"Doc - Tutorial, API docmentation, and development guidlines.","title":"Documentation"},{"location":"#example-projects","text":"fastapi-cosmos-beanie - FastAPI + Beanie ODM + Azure Cosmos Demo Application by Anthony Shaw fastapi-beanie-jwt - Sample FastAPI server with JWT auth and Beanie ODM by Michael duPont","title":"Example Projects"},{"location":"#articles","text":"Announcing Beanie - MongoDB ODM Build a Cocktail API with Beanie and MongoDB MongoDB indexes with Beanie Beanie Projections. Reducing network and database load.","title":"Articles"},{"location":"#resources","text":"GitHub - GitHub page of the project Changelog - list of all the valuable changes Discord - ask your questions, share ideas or just say Hello!! Supported by JetBrains","title":"Resources"},{"location":"changelog/","text":"Changelog Beanie project changes 1.7.0 - 2021-10-12 Added Cache Bulk write exists - find query's method Implementation PR - https://github.com/roman-right/beanie/pull/123 PR - https://github.com/roman-right/beanie/pull/122 PR - https://github.com/roman-right/beanie/pull/129 1.6.1 - 2021-10-06 Update Customization support. It is possible to change query builder classes, used in the classes, which are inherited from the Document class Implementation PR - https://github.com/roman-right/beanie/pull/125 1.6.0 - 2021-09-30 Update Validate on save Implementation PR - https://github.com/roman-right/beanie/pull/118 1.5.1 - 2021-09-27 Update Simplification for init_beanie function Implementation PR - https://github.com/roman-right/beanie/pull/104 1.5.0 - 2021-09-27 Update Custom encoders to be able to configure, how specific type should be presented in the database Implementation Author - Nazar Vovk PR - https://github.com/roman-right/beanie/pull/91 1.4.0 - 2021-09-13 Added Document state management Implementation PR - https://github.com/roman-right/beanie/pull/114 1.3.0 - 2021-09-08 Added Active record pattern Implementation Issue - https://github.com/roman-right/beanie/issues/110 1.2.8 - 2021-09-01 Fix Delete's return annotation Implementation PR - https://github.com/roman-right/beanie/pull/109 1.2.7 - 2021-09-01 Update Annotations for update and delete Implementation Author - Anthony Shaw PR - https://github.com/roman-right/beanie/pull/106 1.2.6 - 2021-08-25 Fixed MongoDB 5.0 in GH actions Implementation PR - https://github.com/roman-right/beanie/pull/100 1.2.5 - 2021-07-21 Fixed Indexed fields work with aliases now Implementation Author - Kira Issue - https://github.com/roman-right/beanie/issues/96 1.2.4 - 2021-07-13 Fixed Aggregation preset method outputs Implementation Issue - https://github.com/roman-right/beanie/issues/91 1.2.3 - 2021-07-08 Fixed Pyright issues Added Doc publishing on merge to the main branch Implementation Issue - https://github.com/roman-right/beanie/issues/87 Issue - https://github.com/roman-right/beanie/issues/70 1.2.2 - 2021-07-06 Fixed Bool types in search criteria Implementation Issue - https://github.com/roman-right/beanie/issues/85 1.2.1 - 2021-07-06 Fixed Document, FindQuery, Aggregation typings Implementation Author - Kira Issue - https://github.com/roman-right/beanie/issues/69 1.2.0 - 2021-06-25 Added Upsert Implementation Issue - https://github.com/roman-right/beanie/issues/64 1.1.6 - 2021-06-21 Fix Pydantic dependency version ^1.5 Implementation PR - https://github.com/roman-right/beanie/pull/71 1.1.5 - 2021-06-17 Fix Convert document id to the right type in the get() method Implementation ISSUE - https://github.com/roman-right/beanie/issues/65 1.1.4 - 2021-06-15 Changed Stricter flake8 and fixing resulting errors Implementation Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/62 1.1.3 - 2021-06-15 Added MyPy to pre-commit Fixed Typing errors Implementation Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/54 1.1.2 - 2021-06-14 Changed Skip migration test when transactions not available Implementation Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/50 1.1.1 - 2021-06-14 Added Save method Implementation Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/47 1.1.0 - 2021-06-02 Added Custom id types. Implementation Issue - https://github.com/roman-right/beanie/issues/12 1.0.6 - 2021-06-01 Fixed Typo in the module name. Implementation Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/44 1.0.5 - 2021-05-25 Fixed Typing. Implementation PR - https://github.com/roman-right/beanie/pull/40 1.0.4 - 2021-05-18 Fixed aggregation_model -> projection_model Implementation PR - https://github.com/roman-right/beanie/pull/39 1.0.3 - 2021-05-16 Added Index kwargs in the Indexed field Implementation Author - Michael duPont PR - https://github.com/roman-right/beanie/pull/32 1.0.2 - 2021-05-16 Fixed Deprecated import Implementation Author - Oliver Andrich PR - https://github.com/roman-right/beanie/pull/33 1.0.1 - 2021-05-14 Fixed Document self annotation Implementation Issue - https://github.com/roman-right/beanie/issues/29 1.0.0 - 2021-05-10 Added QueryBuilder Changed Document class was reworked. Documentation Implementation PR - https://github.com/roman-right/beanie/pull/27 0.4.3 - 2021-04-25 Fixed PydanticObjectId openapi generation 0.4.2 - 2021-04-20 Added Python ^3.6.1 support. Fixed Documents init order in migrations 0.4.1 - 2021-04-19 Added Projections support to reduce database load Implementation Author - Nicholas Smith Issue - https://github.com/roman-right/beanie/issues/16 0.4.0 - 2021-04-18 Added ODM Documentation Changed Documentation 0.4.0b1 - 2021-04-14 Added Migrations inspect_collection Document method count_documents Document method Changed Session can be provided to the most of the Document methods Removed Internal DocumentMeta class. 0.3.4 - 2021-04-09 Changed Indexed(...) field supports index types. Implementation Author - Joran van Apeldoorn 0.3.3 - 2021-04-09 Added Simple indexes via type hints. Implementation Author - Joran van Apeldoorn 0.3.2 - 2021-03-25 Added init_beanie supports also lists of strings with model paths as the document_models parameter. Implementation Author - Mohamed Nesredin 0.3.1 - 2021-03-21 Added skip , limit and sort parameters in the find_many and find_all methods. Documentation 0.3.0 - 2021-03-19 Added Collection - internal class of the Document to set up additional properties. Indexes support. Changed Breaking change: init_beanie is async function now. Deprecated Internal DocumentMeta class. Will be removed in 0.4.0 .","title":"Changelog"},{"location":"changelog/#changelog","text":"Beanie project changes","title":"Changelog"},{"location":"changelog/#170-2021-10-12","text":"","title":"1.7.0 - 2021-10-12"},{"location":"changelog/#added","text":"Cache Bulk write exists - find query's method","title":"Added"},{"location":"changelog/#implementation","text":"PR - https://github.com/roman-right/beanie/pull/123 PR - https://github.com/roman-right/beanie/pull/122 PR - https://github.com/roman-right/beanie/pull/129","title":"Implementation"},{"location":"changelog/#161-2021-10-06","text":"","title":"1.6.1 - 2021-10-06"},{"location":"changelog/#update","text":"Customization support. It is possible to change query builder classes, used in the classes, which are inherited from the Document class","title":"Update"},{"location":"changelog/#implementation_1","text":"PR - https://github.com/roman-right/beanie/pull/125","title":"Implementation"},{"location":"changelog/#160-2021-09-30","text":"","title":"1.6.0 - 2021-09-30"},{"location":"changelog/#update_1","text":"Validate on save","title":"Update"},{"location":"changelog/#implementation_2","text":"PR - https://github.com/roman-right/beanie/pull/118","title":"Implementation"},{"location":"changelog/#151-2021-09-27","text":"","title":"1.5.1 - 2021-09-27"},{"location":"changelog/#update_2","text":"Simplification for init_beanie function","title":"Update"},{"location":"changelog/#implementation_3","text":"PR - https://github.com/roman-right/beanie/pull/104","title":"Implementation"},{"location":"changelog/#150-2021-09-27","text":"","title":"1.5.0 - 2021-09-27"},{"location":"changelog/#update_3","text":"Custom encoders to be able to configure, how specific type should be presented in the database","title":"Update"},{"location":"changelog/#implementation_4","text":"Author - Nazar Vovk PR - https://github.com/roman-right/beanie/pull/91","title":"Implementation"},{"location":"changelog/#140-2021-09-13","text":"","title":"1.4.0 - 2021-09-13"},{"location":"changelog/#added_1","text":"Document state management","title":"Added"},{"location":"changelog/#implementation_5","text":"PR - https://github.com/roman-right/beanie/pull/114","title":"Implementation"},{"location":"changelog/#130-2021-09-08","text":"","title":"1.3.0 - 2021-09-08"},{"location":"changelog/#added_2","text":"Active record pattern","title":"Added"},{"location":"changelog/#implementation_6","text":"Issue - https://github.com/roman-right/beanie/issues/110","title":"Implementation"},{"location":"changelog/#128-2021-09-01","text":"","title":"1.2.8 - 2021-09-01"},{"location":"changelog/#fix","text":"Delete's return annotation","title":"Fix"},{"location":"changelog/#implementation_7","text":"PR - https://github.com/roman-right/beanie/pull/109","title":"Implementation"},{"location":"changelog/#127-2021-09-01","text":"","title":"1.2.7 - 2021-09-01"},{"location":"changelog/#update_4","text":"Annotations for update and delete","title":"Update"},{"location":"changelog/#implementation_8","text":"Author - Anthony Shaw PR - https://github.com/roman-right/beanie/pull/106","title":"Implementation"},{"location":"changelog/#126-2021-08-25","text":"","title":"1.2.6 - 2021-08-25"},{"location":"changelog/#fixed","text":"MongoDB 5.0 in GH actions","title":"Fixed"},{"location":"changelog/#implementation_9","text":"PR - https://github.com/roman-right/beanie/pull/100","title":"Implementation"},{"location":"changelog/#125-2021-07-21","text":"","title":"1.2.5 - 2021-07-21"},{"location":"changelog/#fixed_1","text":"Indexed fields work with aliases now","title":"Fixed"},{"location":"changelog/#implementation_10","text":"Author - Kira Issue - https://github.com/roman-right/beanie/issues/96","title":"Implementation"},{"location":"changelog/#124-2021-07-13","text":"","title":"1.2.4 - 2021-07-13"},{"location":"changelog/#fixed_2","text":"Aggregation preset method outputs","title":"Fixed"},{"location":"changelog/#implementation_11","text":"Issue - https://github.com/roman-right/beanie/issues/91","title":"Implementation"},{"location":"changelog/#123-2021-07-08","text":"","title":"1.2.3 - 2021-07-08"},{"location":"changelog/#fixed_3","text":"Pyright issues","title":"Fixed"},{"location":"changelog/#added_3","text":"Doc publishing on merge to the main branch","title":"Added"},{"location":"changelog/#implementation_12","text":"Issue - https://github.com/roman-right/beanie/issues/87 Issue - https://github.com/roman-right/beanie/issues/70","title":"Implementation"},{"location":"changelog/#122-2021-07-06","text":"","title":"1.2.2 - 2021-07-06"},{"location":"changelog/#fixed_4","text":"Bool types in search criteria","title":"Fixed"},{"location":"changelog/#implementation_13","text":"Issue - https://github.com/roman-right/beanie/issues/85","title":"Implementation"},{"location":"changelog/#121-2021-07-06","text":"","title":"1.2.1 - 2021-07-06"},{"location":"changelog/#fixed_5","text":"Document, FindQuery, Aggregation typings","title":"Fixed"},{"location":"changelog/#implementation_14","text":"Author - Kira Issue - https://github.com/roman-right/beanie/issues/69","title":"Implementation"},{"location":"changelog/#120-2021-06-25","text":"","title":"1.2.0 - 2021-06-25"},{"location":"changelog/#added_4","text":"Upsert","title":"Added"},{"location":"changelog/#implementation_15","text":"Issue - https://github.com/roman-right/beanie/issues/64","title":"Implementation"},{"location":"changelog/#116-2021-06-21","text":"","title":"1.1.6 - 2021-06-21"},{"location":"changelog/#fix_1","text":"Pydantic dependency version ^1.5","title":"Fix"},{"location":"changelog/#implementation_16","text":"PR - https://github.com/roman-right/beanie/pull/71","title":"Implementation"},{"location":"changelog/#115-2021-06-17","text":"","title":"1.1.5 - 2021-06-17"},{"location":"changelog/#fix_2","text":"Convert document id to the right type in the get() method","title":"Fix"},{"location":"changelog/#implementation_17","text":"ISSUE - https://github.com/roman-right/beanie/issues/65","title":"Implementation"},{"location":"changelog/#114-2021-06-15","text":"","title":"1.1.4 - 2021-06-15"},{"location":"changelog/#changed","text":"Stricter flake8 and fixing resulting errors","title":"Changed"},{"location":"changelog/#implementation_18","text":"Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/62","title":"Implementation"},{"location":"changelog/#113-2021-06-15","text":"","title":"1.1.3 - 2021-06-15"},{"location":"changelog/#added_5","text":"MyPy to pre-commit","title":"Added"},{"location":"changelog/#fixed_6","text":"Typing errors","title":"Fixed"},{"location":"changelog/#implementation_19","text":"Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/54","title":"Implementation"},{"location":"changelog/#112-2021-06-14","text":"","title":"1.1.2 - 2021-06-14"},{"location":"changelog/#changed_1","text":"Skip migration test when transactions not available","title":"Changed"},{"location":"changelog/#implementation_20","text":"Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/50","title":"Implementation"},{"location":"changelog/#111-2021-06-14","text":"","title":"1.1.1 - 2021-06-14"},{"location":"changelog/#added_6","text":"Save method","title":"Added"},{"location":"changelog/#implementation_21","text":"Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/47","title":"Implementation"},{"location":"changelog/#110-2021-06-02","text":"","title":"1.1.0 - 2021-06-02"},{"location":"changelog/#added_7","text":"Custom id types.","title":"Added"},{"location":"changelog/#implementation_22","text":"Issue - https://github.com/roman-right/beanie/issues/12","title":"Implementation"},{"location":"changelog/#106-2021-06-01","text":"","title":"1.0.6 - 2021-06-01"},{"location":"changelog/#fixed_7","text":"Typo in the module name.","title":"Fixed"},{"location":"changelog/#implementation_23","text":"Author - Joran van Apeldoorn PR - https://github.com/roman-right/beanie/pull/44","title":"Implementation"},{"location":"changelog/#105-2021-05-25","text":"","title":"1.0.5 - 2021-05-25"},{"location":"changelog/#fixed_8","text":"Typing.","title":"Fixed"},{"location":"changelog/#implementation_24","text":"PR - https://github.com/roman-right/beanie/pull/40","title":"Implementation"},{"location":"changelog/#104-2021-05-18","text":"","title":"1.0.4 - 2021-05-18"},{"location":"changelog/#fixed_9","text":"aggregation_model -> projection_model","title":"Fixed"},{"location":"changelog/#implementation_25","text":"PR - https://github.com/roman-right/beanie/pull/39","title":"Implementation"},{"location":"changelog/#103-2021-05-16","text":"","title":"1.0.3 - 2021-05-16"},{"location":"changelog/#added_8","text":"Index kwargs in the Indexed field","title":"Added"},{"location":"changelog/#implementation_26","text":"Author - Michael duPont PR - https://github.com/roman-right/beanie/pull/32","title":"Implementation"},{"location":"changelog/#102-2021-05-16","text":"","title":"1.0.2 - 2021-05-16"},{"location":"changelog/#fixed_10","text":"Deprecated import","title":"Fixed"},{"location":"changelog/#implementation_27","text":"Author - Oliver Andrich PR - https://github.com/roman-right/beanie/pull/33","title":"Implementation"},{"location":"changelog/#101-2021-05-14","text":"","title":"1.0.1 - 2021-05-14"},{"location":"changelog/#fixed_11","text":"Document self annotation","title":"Fixed"},{"location":"changelog/#implementation_28","text":"Issue - https://github.com/roman-right/beanie/issues/29","title":"Implementation"},{"location":"changelog/#100-2021-05-10","text":"","title":"1.0.0 - 2021-05-10"},{"location":"changelog/#added_9","text":"QueryBuilder","title":"Added"},{"location":"changelog/#changed_2","text":"Document class was reworked. Documentation","title":"Changed"},{"location":"changelog/#implementation_29","text":"PR - https://github.com/roman-right/beanie/pull/27","title":"Implementation"},{"location":"changelog/#043-2021-04-25","text":"","title":"0.4.3 - 2021-04-25"},{"location":"changelog/#fixed_12","text":"PydanticObjectId openapi generation","title":"Fixed"},{"location":"changelog/#042-2021-04-20","text":"","title":"0.4.2 - 2021-04-20"},{"location":"changelog/#added_10","text":"Python ^3.6.1 support.","title":"Added"},{"location":"changelog/#fixed_13","text":"Documents init order in migrations","title":"Fixed"},{"location":"changelog/#041-2021-04-19","text":"","title":"0.4.1 - 2021-04-19"},{"location":"changelog/#added_11","text":"Projections support to reduce database load","title":"Added"},{"location":"changelog/#implementation_30","text":"Author - Nicholas Smith Issue - https://github.com/roman-right/beanie/issues/16","title":"Implementation"},{"location":"changelog/#040-2021-04-18","text":"","title":"0.4.0 - 2021-04-18"},{"location":"changelog/#added_12","text":"ODM Documentation","title":"Added"},{"location":"changelog/#changed_3","text":"Documentation","title":"Changed"},{"location":"changelog/#040b1-2021-04-14","text":"","title":"0.4.0b1 - 2021-04-14"},{"location":"changelog/#added_13","text":"Migrations inspect_collection Document method count_documents Document method","title":"Added"},{"location":"changelog/#changed_4","text":"Session can be provided to the most of the Document methods","title":"Changed"},{"location":"changelog/#removed","text":"Internal DocumentMeta class.","title":"Removed"},{"location":"changelog/#034-2021-04-09","text":"","title":"0.3.4 - 2021-04-09"},{"location":"changelog/#changed_5","text":"Indexed(...) field supports index types.","title":"Changed"},{"location":"changelog/#implementation_31","text":"Author - Joran van Apeldoorn","title":"Implementation"},{"location":"changelog/#033-2021-04-09","text":"","title":"0.3.3 - 2021-04-09"},{"location":"changelog/#added_14","text":"Simple indexes via type hints.","title":"Added"},{"location":"changelog/#implementation_32","text":"Author - Joran van Apeldoorn","title":"Implementation"},{"location":"changelog/#032-2021-03-25","text":"","title":"0.3.2 - 2021-03-25"},{"location":"changelog/#added_15","text":"init_beanie supports also lists of strings with model paths as the document_models parameter.","title":"Added"},{"location":"changelog/#implementation_33","text":"Author - Mohamed Nesredin","title":"Implementation"},{"location":"changelog/#031-2021-03-21","text":"","title":"0.3.1 - 2021-03-21"},{"location":"changelog/#added_16","text":"skip , limit and sort parameters in the find_many and find_all methods. Documentation","title":"Added"},{"location":"changelog/#030-2021-03-19","text":"","title":"0.3.0 - 2021-03-19"},{"location":"changelog/#added_17","text":"Collection - internal class of the Document to set up additional properties. Indexes support.","title":"Added"},{"location":"changelog/#changed_6","text":"Breaking change: init_beanie is async function now.","title":"Changed"},{"location":"changelog/#deprecated","text":"Internal DocumentMeta class. Will be removed in 0.4.0 .","title":"Deprecated"},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at roman-right@protonmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Code of conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at roman-right@protonmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"code-of-conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"code-of-conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"code-of-conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"code-of-conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"code-of-conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"development/","text":"Development Hopefully you have landed here because you would like to help out with the development of Beanie. Whether through adding new features, fixing bugs, or extending documentation, your help is really appreciated! Please read this page carefully. If you have any questions, drop by on the discord. Also please read the Code of conduct . Setting up the development environment We assume you are familiar with the general forking and pull request workflow for submitting to open-source projects. If not, don't worry, there are plenty of good guides available, maybe check out this one. . Beanie uses poetry to manage dependencies and packaging. If you are not familiar with poetry, it might be usefully to read up on it before working on Beanie, but here is a quick guide to get you started. Ensure poetry is installed globally: pip install --user poetry To install all required dependencies in a virtual informant, run the following command in the root of the Beanie project poetry install To add a dependency you can use poetry add <package name> which takes an optional -D flag for development only dependencies. To run commands like pytest or black you have to run them using the virtual environment which contains the dependencies and Beanie. You can do this in two ways, you may run poetry shell to activate the environment for the current shell, or you can run them in a one-off fashion as such poetry run pytest . Database connection To run tests, and use Beanie in general, you will need an accessible MongoDB database. To use migrations you will need a connection to a Replica Set or Mongos instance. All tests assume that the database is hosted localy on port 27017 and does not require authentication. Testing Beanie uses pytest for unit testing. To ensure the stability of Beanie, each added feature must be tested in a separate unit test. Even if it looks like other tests are covering it now. This strategy guarantees that: All the features will be covered and stay covered. Independence from other features and test cases. To run the test suit, make sure that you have mongodb running and run poetry run pytest . Submitting new code You can submit your changes through a pull request on github. Please take into account the following secitons. Use pre-commit To ensure code consistency Beanie uses Black and Flake8 through pre-commit. To set it up, run: poetry install poetry run pre-commit install This will add the pre-commit command to your git's pre-commit hooks and makes sure you can never forget to run these. Single commit To make the pull request reviewing easier and keep the version tree clean your pull request should consist of a single commit. It is natural that your branch might contain multiple commits, so you will need to squash these into a single commit. Instructions can be found here or here Add documentation Please write clear documentation for any new functionallity you add. Docstrings will be converted to the API documentation, but more human friendly documentation might also be needed! See the section below. Working on the documentation The documentation is generated using pydoc-markdown . To see a preview of any edits you make you can run poetry run pydoc-markdown --server and visit the printed adress (usally localhost:8000 ) in your browser. Beware, the autorecompiling might not work for everyone. This will automatically generate the API documentation from source. All other documentation should be written by hand. The documentation is compiled using mkdocs behind the scenes. To change the table of contents or other options, check out pydoc-markdown.yml .","title":"Development"},{"location":"development/#development","text":"Hopefully you have landed here because you would like to help out with the development of Beanie. Whether through adding new features, fixing bugs, or extending documentation, your help is really appreciated! Please read this page carefully. If you have any questions, drop by on the discord. Also please read the Code of conduct .","title":"Development"},{"location":"development/#setting-up-the-development-environment","text":"We assume you are familiar with the general forking and pull request workflow for submitting to open-source projects. If not, don't worry, there are plenty of good guides available, maybe check out this one. . Beanie uses poetry to manage dependencies and packaging. If you are not familiar with poetry, it might be usefully to read up on it before working on Beanie, but here is a quick guide to get you started. Ensure poetry is installed globally: pip install --user poetry To install all required dependencies in a virtual informant, run the following command in the root of the Beanie project poetry install To add a dependency you can use poetry add <package name> which takes an optional -D flag for development only dependencies. To run commands like pytest or black you have to run them using the virtual environment which contains the dependencies and Beanie. You can do this in two ways, you may run poetry shell to activate the environment for the current shell, or you can run them in a one-off fashion as such poetry run pytest .","title":"Setting up the development environment"},{"location":"development/#database-connection","text":"To run tests, and use Beanie in general, you will need an accessible MongoDB database. To use migrations you will need a connection to a Replica Set or Mongos instance. All tests assume that the database is hosted localy on port 27017 and does not require authentication.","title":"Database connection"},{"location":"development/#testing","text":"Beanie uses pytest for unit testing. To ensure the stability of Beanie, each added feature must be tested in a separate unit test. Even if it looks like other tests are covering it now. This strategy guarantees that: All the features will be covered and stay covered. Independence from other features and test cases. To run the test suit, make sure that you have mongodb running and run poetry run pytest .","title":"Testing"},{"location":"development/#submitting-new-code","text":"You can submit your changes through a pull request on github. Please take into account the following secitons.","title":"Submitting new code"},{"location":"development/#use-pre-commit","text":"To ensure code consistency Beanie uses Black and Flake8 through pre-commit. To set it up, run: poetry install poetry run pre-commit install This will add the pre-commit command to your git's pre-commit hooks and makes sure you can never forget to run these.","title":"Use pre-commit"},{"location":"development/#single-commit","text":"To make the pull request reviewing easier and keep the version tree clean your pull request should consist of a single commit. It is natural that your branch might contain multiple commits, so you will need to squash these into a single commit. Instructions can be found here or here","title":"Single commit"},{"location":"development/#add-documentation","text":"Please write clear documentation for any new functionallity you add. Docstrings will be converted to the API documentation, but more human friendly documentation might also be needed! See the section below.","title":"Add documentation"},{"location":"development/#working-on-the-documentation","text":"The documentation is generated using pydoc-markdown . To see a preview of any edits you make you can run poetry run pydoc-markdown --server and visit the printed adress (usally localhost:8000 ) in your browser. Beware, the autorecompiling might not work for everyone. This will automatically generate the API documentation from source. All other documentation should be written by hand. The documentation is compiled using mkdocs behind the scenes. To change the table of contents or other options, check out pydoc-markdown.yml .","title":"Working on the documentation"},{"location":"getting-started/","text":"Getting started Installing beanie You can simply install Beanie for the PyPi: PIP pip install beanie Poetry poetry add beanie Initialization Getting Beanie setup in your code is really easy: Write your database model as a Pydantic class but use beanie.Document in place of pydantic.BaseModel . Initialize Motor, as Beanie uses this as an async database engine under the hood. Call beanie.init_beanie with the Motor client and list of Beanie models The code below should get you started and shows of some of the field types that you can use with beanie. from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed , init_beanie import motor class Category ( BaseModel ): name : str description : str # This is the model that will be saved to the database class Product ( Document ): name : str # You can use normal types just like in pydantic description : Optional [ str ] = None price : Indexed ( float ) # You can also specify that a field should correspond to an index category : Category # You can include pydantic models as well # Call this from within your event loop to get beanie setup. async def init (): # Crete Motor client client = motor . motor_asyncio . AsyncIOMotorClient ( \"mongodb://user:pass@host:27017\" ) # Init beanie with the Product document class await init_beanie ( database = client . db_name , document_models = [ Product ])","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installing-beanie","text":"You can simply install Beanie for the PyPi:","title":"Installing beanie"},{"location":"getting-started/#pip","text":"pip install beanie","title":"PIP"},{"location":"getting-started/#poetry","text":"poetry add beanie","title":"Poetry"},{"location":"getting-started/#initialization","text":"Getting Beanie setup in your code is really easy: Write your database model as a Pydantic class but use beanie.Document in place of pydantic.BaseModel . Initialize Motor, as Beanie uses this as an async database engine under the hood. Call beanie.init_beanie with the Motor client and list of Beanie models The code below should get you started and shows of some of the field types that you can use with beanie. from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed , init_beanie import motor class Category ( BaseModel ): name : str description : str # This is the model that will be saved to the database class Product ( Document ): name : str # You can use normal types just like in pydantic description : Optional [ str ] = None price : Indexed ( float ) # You can also specify that a field should correspond to an index category : Category # You can include pydantic models as well # Call this from within your event loop to get beanie setup. async def init (): # Crete Motor client client = motor . motor_asyncio . AsyncIOMotorClient ( \"mongodb://user:pass@host:27017\" ) # Init beanie with the Product document class await init_beanie ( database = client . db_name , document_models = [ Product ])","title":"Initialization"},{"location":"api-documentation/document/","text":"beanie.odm.documents Document class Document ( BaseModel , UpdateMethods ) Document Mapping class. Fields: id - MongoDB document ObjectID \"_id\" field. Mapped to the PydanticObjectId class Inherited from: Pydantic BaseModel UpdateMethods Document.insert | @wrap_with_actions ( EventTypes . INSERT ) | @save_state_after | @validate_self_before | async insert ( session : Optional [ ClientSession ] = None ) -> DocType Insert the document (self) to the collection Returns : Document Document.create | async create ( session : Optional [ ClientSession ] = None ) -> DocType The same as self.insert() Returns : Document Document.insert_one | @classmethod | async insert_one ( cls : Type [ DocType ], document : DocType , session : Optional [ ClientSession ] = None , bulk_writer : \"BulkWriter\" = None ) -> InsertOneResult Insert one document to the collection Arguments : document : Document - document to insert session : ClientSession - pymongo session bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : InsertOneResult Document.insert_many | @classmethod | async insert_many ( cls : Type [ DocType ], documents : List [ DocType ], session : Optional [ ClientSession ] = None ) -> InsertManyResult Insert many documents to the collection Arguments : documents : List[\"Document\"] - documents to insert session : ClientSession - pymongo session Returns : InsertManyResult Document.get | @classmethod | async get ( cls : Type [ DocType ], document_id : PydanticObjectId , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ DocType ] Get document by id, returns None if document does not exist Arguments : document_id : PydanticObjectId - document id session : Optional[ClientSession] - pymongo session ignore_cache : bool - ignore cache (if it is turned on) Returns : Union[\"Document\", None] Document.find_one | @classmethod | find_one ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindOne [ DocType ], FindOne [ DocumentProjectionType ]] Find one document by criteria. Returns FindOne query object. When awaited this will either return a document or None if no document exists for the search criteria. Arguments : args : *Mapping[str, Any] - search criteria projection_model : Optional[Type[BaseModel]] - projection model session : Optional[ClientSession] - pymongo session instance ignore_cache : bool Returns : FindOne - find query instance Document.find_many | @classmethod | find_many ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] Find many documents by criteria. Returns FindMany query object Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - args : *Mapping[str, Any] - search criteria - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session - ignore_cache : bool Returns : FindMany - query instance Document.find | @classmethod | find ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] The same as find_many Document.find_all | @classmethod | find_all ( cls : Type [ DocType ], skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] Get all the documents Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session Returns : FindMany - query instance Document.all | @classmethod | all ( cls : Type [ DocType ], projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] the same as find_all Document.replace | @wrap_with_actions ( EventTypes . REPLACE ) | @save_state_after | @validate_self_before | async replace ( ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DocType Fully update the document in the database Arguments : Used when revision based protection is turned on. session : Optional[ClientSession] - pymongo session. ignore_revision : bool - do force replace. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : self Document.save | async save ( session : Optional [ ClientSession ] = None ) -> DocType Update an existing model in the database or insert it if it does not yet exist. Arguments : session : Optional[ClientSession] - pymongo session. Returns : None Document.save_changes | @saved_state_needed | @wrap_with_actions ( EventTypes . SAVE_CHANGES ) | @validate_self_before | async save_changes ( ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> None Save changes. State management usage must be turned on Arguments : ignore_revision : bool - ignore revision id, if revision is turned on bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : None Document.replace_many | @classmethod | async replace_many ( cls : Type [ DocType ], documents : List [ DocType ], session : Optional [ ClientSession ] = None ) -> None Replace list of documents Arguments : documents : List[\"Document\"] session : Optional[ClientSession] - pymongo session. Returns : None Document.update | @save_state_after | async update ( * args , * , ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> None Partially update the document in the database Arguments : is not the same, as stored - args : *Union[dict, Mapping] - the modifications to apply. - session : ClientSession - pymongo session. - ignore_revision : bool - force update. Will update even if revision id - bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : None Document.update_all | @classmethod | update_all ( cls , * args : Union [ dict , Mapping ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateMany Partially update all the documents Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : ClientSession - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query Document.delete | async delete ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ DeleteResult ] Delete the document Arguments : session : Optional[ClientSession] - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : Optional[DeleteResult] - pymongo DeleteResult instance. Document.delete_all | @classmethod | async delete_all ( cls , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ DeleteResult ] Delete all the documents Arguments : session : Optional[ClientSession] - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : Optional[DeleteResult] - pymongo DeleteResult instance. Document.aggregate | @classmethod | aggregate ( cls : Type [ DocType ], aggregation_pipeline : list , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | AggregationQuery [ Dict [ str , Any ]], | AggregationQuery [ DocumentProjectionType ], | ] Aggregate over collection. Returns AggregationQuery query object Arguments : aggregation_pipeline : list - aggregation pipeline projection_model : Type[BaseModel] session : Optional[ClientSession] ignore_cache : bool Returns : AggregationQuery Document.count | @classmethod | async count ( cls ) -> int Number of documents in the collections The same as find_all().count() Returns : int Document.use_state_management | @classmethod | use_state_management ( cls ) -> bool Is state management turned on Returns : bool Document.get_saved_state | get_saved_state () -> Optional [ Dict [ str , Any ]] Saved state getter. It is protected property. Returns : Optional[Dict[str, Any]] - saved state Document.init_cache | @classmethod | init_cache ( cls ) -> None Init model's cache Returns : None Document.init_fields | @classmethod | init_fields ( cls ) -> None Init class fields Returns : None Document.init_settings | @classmethod | async init_settings ( cls , database : AsyncIOMotorDatabase , allow_index_dropping : bool ) -> None Init document settings (collection and models) Arguments : database : AsyncIOMotorDatabase - motor database allow_index_dropping : bool Returns : None Document.init_model | @classmethod | async init_model ( cls , database : AsyncIOMotorDatabase , allow_index_dropping : bool ) -> None Init wrapper Arguments : database : AsyncIOMotorDatabase allow_index_dropping : bool Returns : None Document.get_settings | @classmethod | get_settings ( cls ) -> DocumentSettings Get document settings, which was created on the initialization step Returns : DocumentSettings class Document.get_motor_collection | @classmethod | get_motor_collection ( cls ) -> AsyncIOMotorCollection Get Motor Collection to access low level control Returns : AsyncIOMotorCollection Document.inspect_collection | @classmethod | async inspect_collection ( cls , session : Optional [ ClientSession ] = None ) -> InspectionResult Check, if documents, stored in the MongoDB collection are compatible with the Document schema Returns : InspectionResult","title":"Document"},{"location":"api-documentation/document/#beanieodmdocuments","text":"","title":"beanie.odm.documents"},{"location":"api-documentation/document/#document","text":"class Document ( BaseModel , UpdateMethods ) Document Mapping class. Fields: id - MongoDB document ObjectID \"_id\" field. Mapped to the PydanticObjectId class Inherited from: Pydantic BaseModel UpdateMethods","title":"Document"},{"location":"api-documentation/document/#documentinsert","text":"| @wrap_with_actions ( EventTypes . INSERT ) | @save_state_after | @validate_self_before | async insert ( session : Optional [ ClientSession ] = None ) -> DocType Insert the document (self) to the collection Returns : Document","title":"Document.insert"},{"location":"api-documentation/document/#documentcreate","text":"| async create ( session : Optional [ ClientSession ] = None ) -> DocType The same as self.insert() Returns : Document","title":"Document.create"},{"location":"api-documentation/document/#documentinsert_one","text":"| @classmethod | async insert_one ( cls : Type [ DocType ], document : DocType , session : Optional [ ClientSession ] = None , bulk_writer : \"BulkWriter\" = None ) -> InsertOneResult Insert one document to the collection Arguments : document : Document - document to insert session : ClientSession - pymongo session bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : InsertOneResult","title":"Document.insert_one"},{"location":"api-documentation/document/#documentinsert_many","text":"| @classmethod | async insert_many ( cls : Type [ DocType ], documents : List [ DocType ], session : Optional [ ClientSession ] = None ) -> InsertManyResult Insert many documents to the collection Arguments : documents : List[\"Document\"] - documents to insert session : ClientSession - pymongo session Returns : InsertManyResult","title":"Document.insert_many"},{"location":"api-documentation/document/#documentget","text":"| @classmethod | async get ( cls : Type [ DocType ], document_id : PydanticObjectId , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ DocType ] Get document by id, returns None if document does not exist Arguments : document_id : PydanticObjectId - document id session : Optional[ClientSession] - pymongo session ignore_cache : bool - ignore cache (if it is turned on) Returns : Union[\"Document\", None]","title":"Document.get"},{"location":"api-documentation/document/#documentfind_one","text":"| @classmethod | find_one ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindOne [ DocType ], FindOne [ DocumentProjectionType ]] Find one document by criteria. Returns FindOne query object. When awaited this will either return a document or None if no document exists for the search criteria. Arguments : args : *Mapping[str, Any] - search criteria projection_model : Optional[Type[BaseModel]] - projection model session : Optional[ClientSession] - pymongo session instance ignore_cache : bool Returns : FindOne - find query instance","title":"Document.find_one"},{"location":"api-documentation/document/#documentfind_many","text":"| @classmethod | find_many ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] Find many documents by criteria. Returns FindMany query object Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - args : *Mapping[str, Any] - search criteria - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session - ignore_cache : bool Returns : FindMany - query instance","title":"Document.find_many"},{"location":"api-documentation/document/#documentfind","text":"| @classmethod | find ( cls : Type [ DocType ], * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] The same as find_many","title":"Document.find"},{"location":"api-documentation/document/#documentfind_all","text":"| @classmethod | find_all ( cls : Type [ DocType ], skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] Get all the documents Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session Returns : FindMany - query instance","title":"Document.find_all"},{"location":"api-documentation/document/#documentall","text":"| @classmethod | all ( cls : Type [ DocType ], projection_model : Optional [ Type [ DocumentProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ FindMany [ DocType ], FindMany [ DocumentProjectionType ]] the same as find_all","title":"Document.all"},{"location":"api-documentation/document/#documentreplace","text":"| @wrap_with_actions ( EventTypes . REPLACE ) | @save_state_after | @validate_self_before | async replace ( ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DocType Fully update the document in the database Arguments : Used when revision based protection is turned on. session : Optional[ClientSession] - pymongo session. ignore_revision : bool - do force replace. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : self","title":"Document.replace"},{"location":"api-documentation/document/#documentsave","text":"| async save ( session : Optional [ ClientSession ] = None ) -> DocType Update an existing model in the database or insert it if it does not yet exist. Arguments : session : Optional[ClientSession] - pymongo session. Returns : None","title":"Document.save"},{"location":"api-documentation/document/#documentsave_changes","text":"| @saved_state_needed | @wrap_with_actions ( EventTypes . SAVE_CHANGES ) | @validate_self_before | async save_changes ( ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> None Save changes. State management usage must be turned on Arguments : ignore_revision : bool - ignore revision id, if revision is turned on bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : None","title":"Document.save_changes"},{"location":"api-documentation/document/#documentreplace_many","text":"| @classmethod | async replace_many ( cls : Type [ DocType ], documents : List [ DocType ], session : Optional [ ClientSession ] = None ) -> None Replace list of documents Arguments : documents : List[\"Document\"] session : Optional[ClientSession] - pymongo session. Returns : None","title":"Document.replace_many"},{"location":"api-documentation/document/#documentupdate","text":"| @save_state_after | async update ( * args , * , ignore_revision : bool = False , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> None Partially update the document in the database Arguments : is not the same, as stored - args : *Union[dict, Mapping] - the modifications to apply. - session : ClientSession - pymongo session. - ignore_revision : bool - force update. Will update even if revision id - bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : None","title":"Document.update"},{"location":"api-documentation/document/#documentupdate_all","text":"| @classmethod | update_all ( cls , * args : Union [ dict , Mapping ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateMany Partially update all the documents Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : ClientSession - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query","title":"Document.update_all"},{"location":"api-documentation/document/#documentdelete","text":"| async delete ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ DeleteResult ] Delete the document Arguments : session : Optional[ClientSession] - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : Optional[DeleteResult] - pymongo DeleteResult instance.","title":"Document.delete"},{"location":"api-documentation/document/#documentdelete_all","text":"| @classmethod | async delete_all ( cls , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ DeleteResult ] Delete all the documents Arguments : session : Optional[ClientSession] - pymongo session. bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : Optional[DeleteResult] - pymongo DeleteResult instance.","title":"Document.delete_all"},{"location":"api-documentation/document/#documentaggregate","text":"| @classmethod | aggregate ( cls : Type [ DocType ], aggregation_pipeline : list , projection_model : Optional [ Type [ DocumentProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | AggregationQuery [ Dict [ str , Any ]], | AggregationQuery [ DocumentProjectionType ], | ] Aggregate over collection. Returns AggregationQuery query object Arguments : aggregation_pipeline : list - aggregation pipeline projection_model : Type[BaseModel] session : Optional[ClientSession] ignore_cache : bool Returns : AggregationQuery","title":"Document.aggregate"},{"location":"api-documentation/document/#documentcount","text":"| @classmethod | async count ( cls ) -> int Number of documents in the collections The same as find_all().count() Returns : int","title":"Document.count"},{"location":"api-documentation/document/#documentuse_state_management","text":"| @classmethod | use_state_management ( cls ) -> bool Is state management turned on Returns : bool","title":"Document.use_state_management"},{"location":"api-documentation/document/#documentget_saved_state","text":"| get_saved_state () -> Optional [ Dict [ str , Any ]] Saved state getter. It is protected property. Returns : Optional[Dict[str, Any]] - saved state","title":"Document.get_saved_state"},{"location":"api-documentation/document/#documentinit_cache","text":"| @classmethod | init_cache ( cls ) -> None Init model's cache Returns : None","title":"Document.init_cache"},{"location":"api-documentation/document/#documentinit_fields","text":"| @classmethod | init_fields ( cls ) -> None Init class fields Returns : None","title":"Document.init_fields"},{"location":"api-documentation/document/#documentinit_settings","text":"| @classmethod | async init_settings ( cls , database : AsyncIOMotorDatabase , allow_index_dropping : bool ) -> None Init document settings (collection and models) Arguments : database : AsyncIOMotorDatabase - motor database allow_index_dropping : bool Returns : None","title":"Document.init_settings"},{"location":"api-documentation/document/#documentinit_model","text":"| @classmethod | async init_model ( cls , database : AsyncIOMotorDatabase , allow_index_dropping : bool ) -> None Init wrapper Arguments : database : AsyncIOMotorDatabase allow_index_dropping : bool Returns : None","title":"Document.init_model"},{"location":"api-documentation/document/#documentget_settings","text":"| @classmethod | get_settings ( cls ) -> DocumentSettings Get document settings, which was created on the initialization step Returns : DocumentSettings class","title":"Document.get_settings"},{"location":"api-documentation/document/#documentget_motor_collection","text":"| @classmethod | get_motor_collection ( cls ) -> AsyncIOMotorCollection Get Motor Collection to access low level control Returns : AsyncIOMotorCollection","title":"Document.get_motor_collection"},{"location":"api-documentation/document/#documentinspect_collection","text":"| @classmethod | async inspect_collection ( cls , session : Optional [ ClientSession ] = None ) -> InspectionResult Check, if documents, stored in the MongoDB collection are compatible with the Document schema Returns : InspectionResult","title":"Document.inspect_collection"},{"location":"api-documentation/fields/","text":"beanie.odm.fields Indexed Indexed ( typ , index_type = ASCENDING , ** kwargs ) Returns a subclass of typ with an extra attribute _indexed as a tuple: - Index 0: index_type such as pymongo.ASCENDING - Index 1: kwargs passed to IndexModel When instantiated the type of the result will actually be typ . PydanticObjectId class PydanticObjectId ( ObjectId ) Object Id field. Compatible with Pydantic. ExpressionField class ExpressionField ( str ) ExpressionField.__getattr__ | __getattr__ ( item ) Get sub field Arguments : item : name of the subfield Returns : ExpressionField","title":"Fields"},{"location":"api-documentation/fields/#beanieodmfields","text":"","title":"beanie.odm.fields"},{"location":"api-documentation/fields/#indexed","text":"Indexed ( typ , index_type = ASCENDING , ** kwargs ) Returns a subclass of typ with an extra attribute _indexed as a tuple: - Index 0: index_type such as pymongo.ASCENDING - Index 1: kwargs passed to IndexModel When instantiated the type of the result will actually be typ .","title":"Indexed"},{"location":"api-documentation/fields/#pydanticobjectid","text":"class PydanticObjectId ( ObjectId ) Object Id field. Compatible with Pydantic.","title":"PydanticObjectId"},{"location":"api-documentation/fields/#expressionfield","text":"class ExpressionField ( str )","title":"ExpressionField"},{"location":"api-documentation/fields/#expressionfield__getattr__","text":"| __getattr__ ( item ) Get sub field Arguments : item : name of the subfield Returns : ExpressionField","title":"ExpressionField.__getattr__"},{"location":"api-documentation/interfaces/","text":"beanie.odm.interfaces.update UpdateMethods class UpdateMethods () Update methods UpdateMethods.set | set ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Set values Example: class Sample ( Document ): one : int await Document . find ( Sample . one == 1 ) . set ({ Sample . one : 100 }) Uses Set operator Arguments : values to set - expression : Dict[Union[ExpressionField, str], Any] - keys and - session : Optional[ClientSession] - pymongo session - bulk_writer : Optional[BulkWriter] - bulk writer Returns : self UpdateMethods.current_date | current_date ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Set current date Uses CurrentDate operator Arguments : expression : Dict[Union[ExpressionField, str], Any] session : Optional[ClientSession] - pymongo session bulk_writer : Optional[BulkWriter] - bulk writer Returns : self UpdateMethods.inc | inc ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Increment Example: class Sample ( Document ): one : int await Document . find ( Sample . one == 1 ) . inc ({ Sample . one : 100 }) Uses Inc operator Arguments : expression : Dict[Union[ExpressionField, str], Any] session : Optional[ClientSession] - pymongo session bulk_writer : Optional[BulkWriter] - bulk writer Returns : self beanie.odm.interfaces.session SessionMethods class SessionMethods () Session methods SessionMethods.set_session | set_session ( session : Optional [ ClientSession ] = None ) Set pymongo session Arguments : session : Optional[ClientSession] - pymongo session Returns : beanie.odm.interfaces.aggregate AggregateMethods class AggregateMethods () Aggregate methods AggregateMethods.sum | async sum ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Sum of values of the given field Example: class Sample ( Document ): price : int count : int sum_count = await Document . find ( Sample . price <= 100 ) . sum ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : float - sum. None if there are no items. AggregateMethods.avg | async avg ( field , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Average of values of the given field Example: class Sample ( Document ): price : int count : int avg_count = await Document . find ( Sample . price <= 100 ) . avg ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : Optional[float] - avg. None if there are no items. AggregateMethods.max | async max ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Max of the values of the given field Example: class Sample ( Document ): price : int count : int max_count = await Document . find ( Sample . price <= 100 ) . max ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session Returns : float - max. None if there are no items. AggregateMethods.min | async min ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Min of the values of the given field Example: class Sample ( Document ): price : int count : int min_count = await Document . find ( Sample . price <= 100 ) . min ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session Returns : float - min. None if there are no items.","title":"Interfaces"},{"location":"api-documentation/interfaces/#beanieodminterfacesupdate","text":"","title":"beanie.odm.interfaces.update"},{"location":"api-documentation/interfaces/#updatemethods","text":"class UpdateMethods () Update methods","title":"UpdateMethods"},{"location":"api-documentation/interfaces/#updatemethodsset","text":"| set ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Set values Example: class Sample ( Document ): one : int await Document . find ( Sample . one == 1 ) . set ({ Sample . one : 100 }) Uses Set operator Arguments : values to set - expression : Dict[Union[ExpressionField, str], Any] - keys and - session : Optional[ClientSession] - pymongo session - bulk_writer : Optional[BulkWriter] - bulk writer Returns : self","title":"UpdateMethods.set"},{"location":"api-documentation/interfaces/#updatemethodscurrent_date","text":"| current_date ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Set current date Uses CurrentDate operator Arguments : expression : Dict[Union[ExpressionField, str], Any] session : Optional[ClientSession] - pymongo session bulk_writer : Optional[BulkWriter] - bulk writer Returns : self","title":"UpdateMethods.current_date"},{"location":"api-documentation/interfaces/#updatemethodsinc","text":"| inc ( expression : Dict [ Union [ ExpressionField , str ], Any ], session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs ) Increment Example: class Sample ( Document ): one : int await Document . find ( Sample . one == 1 ) . inc ({ Sample . one : 100 }) Uses Inc operator Arguments : expression : Dict[Union[ExpressionField, str], Any] session : Optional[ClientSession] - pymongo session bulk_writer : Optional[BulkWriter] - bulk writer Returns : self","title":"UpdateMethods.inc"},{"location":"api-documentation/interfaces/#beanieodminterfacessession","text":"","title":"beanie.odm.interfaces.session"},{"location":"api-documentation/interfaces/#sessionmethods","text":"class SessionMethods () Session methods","title":"SessionMethods"},{"location":"api-documentation/interfaces/#sessionmethodsset_session","text":"| set_session ( session : Optional [ ClientSession ] = None ) Set pymongo session Arguments : session : Optional[ClientSession] - pymongo session Returns :","title":"SessionMethods.set_session"},{"location":"api-documentation/interfaces/#beanieodminterfacesaggregate","text":"","title":"beanie.odm.interfaces.aggregate"},{"location":"api-documentation/interfaces/#aggregatemethods","text":"class AggregateMethods () Aggregate methods","title":"AggregateMethods"},{"location":"api-documentation/interfaces/#aggregatemethodssum","text":"| async sum ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Sum of values of the given field Example: class Sample ( Document ): price : int count : int sum_count = await Document . find ( Sample . price <= 100 ) . sum ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : float - sum. None if there are no items.","title":"AggregateMethods.sum"},{"location":"api-documentation/interfaces/#aggregatemethodsavg","text":"| async avg ( field , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Average of values of the given field Example: class Sample ( Document ): price : int count : int avg_count = await Document . find ( Sample . price <= 100 ) . avg ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : Optional[float] - avg. None if there are no items.","title":"AggregateMethods.avg"},{"location":"api-documentation/interfaces/#aggregatemethodsmax","text":"| async max ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Max of the values of the given field Example: class Sample ( Document ): price : int count : int max_count = await Document . find ( Sample . price <= 100 ) . max ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session Returns : float - max. None if there are no items.","title":"AggregateMethods.max"},{"location":"api-documentation/interfaces/#aggregatemethodsmin","text":"| async min ( field : Union [ str , ExpressionField ], session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Optional [ float ] Min of the values of the given field Example: class Sample ( Document ): price : int count : int min_count = await Document . find ( Sample . price <= 100 ) . min ( Sample . count ) Arguments : field : Union[str, ExpressionField] session : Optional[ClientSession] - pymongo session Returns : float - min. None if there are no items.","title":"AggregateMethods.min"},{"location":"api-documentation/query/","text":"beanie.odm.queries.update UpdateQuery class UpdateQuery ( UpdateMethods , SessionMethods ) Update Query base class Inherited from: SessionMethods UpdateMethods UpdateQuery.update | update ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs , ,) -> \"UpdateQuery\" Provide modifications to the update query. Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : Optional[BulkWriter] Returns : UpdateMany query UpdateQuery.upsert | upsert ( * args : Mapping [ str , Any ], * , on_insert : \"DocType\" , session : Optional [ ClientSession ] = None ) -> \"UpdateQuery\" Provide modifications to the upsert query. Arguments : document in the collection - args : *Union[dict, Mapping] - the modifications to apply. - on_insert : DocType - document to insert if there is no matched - session : Optional[ClientSession] Returns : UpdateMany query UpdateQuery.__await__ | __await__ () -> Generator [ Any , None , Union [ UpdateResult , InsertOneResult ]] Run the query Returns : UpdateMany class UpdateMany ( UpdateQuery ) Update Many query class Inherited from: UpdateQuery UpdateMany.update_many | update_many ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) Provide modifications to the update query Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query UpdateOne class UpdateOne ( UpdateQuery ) Update One query class Inherited from: UpdateQuery UpdateOne.update_one | update_one ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) Provide modifications to the update query. The same as update() Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query beanie.odm.queries.find FindQuery class FindQuery ( Generic [ FindQueryResultType ], UpdateMethods , SessionMethods ) Find Query base class Inherited from: SessionMethods UpdateMethods FindQuery.update | update ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs , ,) Create Update with modifications query and provide search criteria there Arguments : args : *Mapping[str,Any] - the modifications to apply. session : Optional[ClientSession] Returns : UpdateMany query FindQuery.upsert | upsert ( * args : Mapping [ str , Any ], * , on_insert : \"DocType\" , session : Optional [ ClientSession ] = None ) Create Update with modifications query and provide search criteria there Arguments : document in the collection - args : *Mapping[str,Any] - the modifications to apply. - on_insert : DocType - document to insert if there is no matched - session : Optional[ClientSession] Returns : UpdateMany query FindQuery.delete | delete ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Union [ DeleteOne , DeleteMany ] Provide search criteria to the Delete query Arguments : session : Optional[ClientSession] Returns : Union[DeleteOne, DeleteMany] FindQuery.project | project ( projection_model ) Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self FindQuery.count | async count () -> int Number of found documents Returns : int FindQuery.exists | async exists () -> bool If find query will return anything Returns : bool FindMany class FindMany ( FindQuery [ FindQueryResultType ], BaseCursorQuery [ FindQueryResultType ], AggregateMethods ) Find Many query class Inherited from: FindQuery BaseCursorQuery - async generator AggregateMethods FindMany.find_many | find_many ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] Find many documents by criteria Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - args : *Mapping[str, Any] - search criteria - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session - ignore_cache : bool Returns : FindMany - query instance FindMany.project | project ( projection_model : Optional [ Type [ FindQueryProjectionType ]]) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self FindMany.find | find ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] The same as find_many(...) FindMany.sort | sort ( * args : Optional [ | Union [ | str , Tuple [ str , SortDirection ], List [ Tuple [ str , SortDirection ]] | ] | ]) -> \"FindMany[FindQueryResultType]\" Add sort parameters Arguments : List[Tuple[str, SortDirection]]] - A key or a tuple (key, direction) or a list of (key, direction) pairs specifying the sort order for this query. - args : Union[str, Tuple[str, SortDirection], Returns : self FindMany.skip | skip ( n : Optional [ int ]) -> \"FindMany[FindQueryResultType]\" Set skip parameter Arguments : n : int Returns : self FindMany.limit | limit ( n : Optional [ int ]) -> \"FindMany[FindQueryResultType]\" Set limit parameter Arguments : n : int Returns : FindMany.update_many | update_many ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateMany Provide search criteria to the UpdateMany query Arguments : args : *Mappingp[str,Any] - the modifications to apply. session : Optional[ClientSession] Returns : UpdateMany query FindMany.delete_many | delete_many ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DeleteMany Provide search criteria to the DeleteMany query Arguments : session : Returns : DeleteMany query FindMany.aggregate | aggregate ( aggregation_pipeline : List [ Any ], projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | AggregationQuery [ Dict [ str , Any ]], | AggregationQuery [ FindQueryProjectionType ], | ] Provide search criteria to the AggregationQuery Arguments : https://docs.mongodb.com/manual/core/aggregation-pipeline/ - aggregation_pipeline : list - aggregation pipeline. MongoDB doc: - projection_model : Type[BaseModel] - Projection Model - session : Optional[ClientSession] - PyMongo session - ignore_cache : bool Returns : AggregationQuery FindOne class FindOne ( FindQuery [ FindQueryResultType ]) Find One query class Inherited from: FindQuery FindOne.project | project ( projection_model : Optional [ Type [ FindQueryProjectionType ]] = None ) -> Union [ | \"FindOne[FindQueryResultType]\" , \"FindOne[FindQueryProjectionType]\" | ] Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self FindOne.find_one | find_one ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindOne[FindQueryResultType]\" , \"FindOne[FindQueryProjectionType]\" | ] Find one document by criteria Arguments : args : *Mapping[str, Any] - search criteria projection_model : Optional[Type[BaseModel]] - projection model session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : FindOne - query instance FindOne.update_one | update_one ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateOne Create UpdateOne query using modifications and provide search criteria there Arguments : args : *Mapping[str,Any] - the modifications to apply session : Optional[ClientSession] - PyMongo sessions Returns : UpdateOne query FindOne.delete_one | delete_one ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DeleteOne Provide search criteria to the DeleteOne query Arguments : session : Optional[ClientSession] - PyMongo sessions Returns : DeleteOne query FindOne.replace_one | async replace_one ( document : \"DocType\" , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ UpdateResult ] Replace found document by provided Arguments : document : Document - document, which will replace the found one session : Optional[ClientSession] - PyMongo session bulk_writer : Optional[BulkWriter] - Beanie bulk writer Returns : UpdateResult FindOne.__await__ | __await__ () -> Generator [ Coroutine , Any , Optional [ FindQueryResultType ]] Run the query Returns : BaseModel beanie.odm.queries.cursor BaseCursorQuery class BaseCursorQuery ( Generic [ CursorResultType ]) BaseCursorQuery class. Wrapper over AsyncIOMotorCursor, which parse result with model BaseCursorQuery.to_list | async to_list ( length : Optional [ int ] = None ) -> List [ CursorResultType ] Get list of documents Arguments : length : Optional[int] - length of the list Returns : Union[List[BaseModel], List[Dict[str, Any]]] beanie.odm.queries.aggregation AggregationQuery class AggregationQuery ( Generic [ AggregationProjectionType ], BaseCursorQuery [ AggregationProjectionType ], SessionMethods ) Aggregation Query Inherited from: SessionMethods - session methods BaseCursorQuery - async generator beanie.odm.queries.delete DeleteQuery class DeleteQuery ( SessionMethods ) Deletion Query DeleteMany class DeleteMany ( DeleteQuery ) DeleteMany.__await__ | __await__ () -> Generator [ DeleteResult , None , None ] Run the query Returns : DeleteOne class DeleteOne ( DeleteQuery ) DeleteOne.__await__ | __await__ () -> Generator [ DeleteResult , None , None ] Run the query Returns :","title":"Query"},{"location":"api-documentation/query/#beanieodmqueriesupdate","text":"","title":"beanie.odm.queries.update"},{"location":"api-documentation/query/#updatequery","text":"class UpdateQuery ( UpdateMethods , SessionMethods ) Update Query base class Inherited from: SessionMethods UpdateMethods","title":"UpdateQuery"},{"location":"api-documentation/query/#updatequeryupdate","text":"| update ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs , ,) -> \"UpdateQuery\" Provide modifications to the update query. Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : Optional[BulkWriter] Returns : UpdateMany query","title":"UpdateQuery.update"},{"location":"api-documentation/query/#updatequeryupsert","text":"| upsert ( * args : Mapping [ str , Any ], * , on_insert : \"DocType\" , session : Optional [ ClientSession ] = None ) -> \"UpdateQuery\" Provide modifications to the upsert query. Arguments : document in the collection - args : *Union[dict, Mapping] - the modifications to apply. - on_insert : DocType - document to insert if there is no matched - session : Optional[ClientSession] Returns : UpdateMany query","title":"UpdateQuery.upsert"},{"location":"api-documentation/query/#updatequery__await__","text":"| __await__ () -> Generator [ Any , None , Union [ UpdateResult , InsertOneResult ]] Run the query Returns :","title":"UpdateQuery.__await__"},{"location":"api-documentation/query/#updatemany","text":"class UpdateMany ( UpdateQuery ) Update Many query class Inherited from: UpdateQuery","title":"UpdateMany"},{"location":"api-documentation/query/#updatemanyupdate_many","text":"| update_many ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) Provide modifications to the update query Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query","title":"UpdateMany.update_many"},{"location":"api-documentation/query/#updateone","text":"class UpdateOne ( UpdateQuery ) Update One query class Inherited from: UpdateQuery","title":"UpdateOne"},{"location":"api-documentation/query/#updateoneupdate_one","text":"| update_one ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) Provide modifications to the update query. The same as update() Arguments : args : *Union[dict, Mapping] - the modifications to apply. session : Optional[ClientSession] bulk_writer : \"BulkWriter\" - Beanie bulk writer Returns : UpdateMany query","title":"UpdateOne.update_one"},{"location":"api-documentation/query/#beanieodmqueriesfind","text":"","title":"beanie.odm.queries.find"},{"location":"api-documentation/query/#findquery","text":"class FindQuery ( Generic [ FindQueryResultType ], UpdateMethods , SessionMethods ) Find Query base class Inherited from: SessionMethods UpdateMethods","title":"FindQuery"},{"location":"api-documentation/query/#findqueryupdate","text":"| update ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None , ** kwargs , ,) Create Update with modifications query and provide search criteria there Arguments : args : *Mapping[str,Any] - the modifications to apply. session : Optional[ClientSession] Returns : UpdateMany query","title":"FindQuery.update"},{"location":"api-documentation/query/#findqueryupsert","text":"| upsert ( * args : Mapping [ str , Any ], * , on_insert : \"DocType\" , session : Optional [ ClientSession ] = None ) Create Update with modifications query and provide search criteria there Arguments : document in the collection - args : *Mapping[str,Any] - the modifications to apply. - on_insert : DocType - document to insert if there is no matched - session : Optional[ClientSession] Returns : UpdateMany query","title":"FindQuery.upsert"},{"location":"api-documentation/query/#findquerydelete","text":"| delete ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Union [ DeleteOne , DeleteMany ] Provide search criteria to the Delete query Arguments : session : Optional[ClientSession] Returns : Union[DeleteOne, DeleteMany]","title":"FindQuery.delete"},{"location":"api-documentation/query/#findqueryproject","text":"| project ( projection_model ) Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self","title":"FindQuery.project"},{"location":"api-documentation/query/#findquerycount","text":"| async count () -> int Number of found documents Returns : int","title":"FindQuery.count"},{"location":"api-documentation/query/#findqueryexists","text":"| async exists () -> bool If find query will return anything Returns : bool","title":"FindQuery.exists"},{"location":"api-documentation/query/#findmany","text":"class FindMany ( FindQuery [ FindQueryResultType ], BaseCursorQuery [ FindQueryResultType ], AggregateMethods ) Find Many query class Inherited from: FindQuery BaseCursorQuery - async generator AggregateMethods","title":"FindMany"},{"location":"api-documentation/query/#findmanyfind_many","text":"| find_many ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] Find many documents by criteria Arguments : or a list of (key, direction) pairs specifying the sort order for this query. - args : *Mapping[str, Any] - search criteria - skip : Optional[int] - The number of documents to omit. - limit : Optional[int] - The maximum number of results to return. - sort : Union[None, str, List[Tuple[str, SortDirection]]] - A key - projection_model : Optional[Type[BaseModel]] - projection model - session : Optional[ClientSession] - pymongo session - ignore_cache : bool Returns : FindMany - query instance","title":"FindMany.find_many"},{"location":"api-documentation/query/#findmanyproject","text":"| project ( projection_model : Optional [ Type [ FindQueryProjectionType ]]) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self","title":"FindMany.project"},{"location":"api-documentation/query/#findmanyfind","text":"| find ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , skip : Optional [ int ] = None , limit : Optional [ int ] = None , sort : Union [ None , str , List [ Tuple [ str , SortDirection ]]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindMany[FindQueryResultType]\" , \"FindMany[FindQueryProjectionType]\" | ] The same as find_many(...)","title":"FindMany.find"},{"location":"api-documentation/query/#findmanysort","text":"| sort ( * args : Optional [ | Union [ | str , Tuple [ str , SortDirection ], List [ Tuple [ str , SortDirection ]] | ] | ]) -> \"FindMany[FindQueryResultType]\" Add sort parameters Arguments : List[Tuple[str, SortDirection]]] - A key or a tuple (key, direction) or a list of (key, direction) pairs specifying the sort order for this query. - args : Union[str, Tuple[str, SortDirection], Returns : self","title":"FindMany.sort"},{"location":"api-documentation/query/#findmanyskip","text":"| skip ( n : Optional [ int ]) -> \"FindMany[FindQueryResultType]\" Set skip parameter Arguments : n : int Returns : self","title":"FindMany.skip"},{"location":"api-documentation/query/#findmanylimit","text":"| limit ( n : Optional [ int ]) -> \"FindMany[FindQueryResultType]\" Set limit parameter Arguments : n : int Returns :","title":"FindMany.limit"},{"location":"api-documentation/query/#findmanyupdate_many","text":"| update_many ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateMany Provide search criteria to the UpdateMany query Arguments : args : *Mappingp[str,Any] - the modifications to apply. session : Optional[ClientSession] Returns : UpdateMany query","title":"FindMany.update_many"},{"location":"api-documentation/query/#findmanydelete_many","text":"| delete_many ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DeleteMany Provide search criteria to the DeleteMany query Arguments : session : Returns : DeleteMany query","title":"FindMany.delete_many"},{"location":"api-documentation/query/#findmanyaggregate","text":"| aggregate ( aggregation_pipeline : List [ Any ], projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | AggregationQuery [ Dict [ str , Any ]], | AggregationQuery [ FindQueryProjectionType ], | ] Provide search criteria to the AggregationQuery Arguments : https://docs.mongodb.com/manual/core/aggregation-pipeline/ - aggregation_pipeline : list - aggregation pipeline. MongoDB doc: - projection_model : Type[BaseModel] - Projection Model - session : Optional[ClientSession] - PyMongo session - ignore_cache : bool Returns : AggregationQuery","title":"FindMany.aggregate"},{"location":"api-documentation/query/#findone","text":"class FindOne ( FindQuery [ FindQueryResultType ]) Find One query class Inherited from: FindQuery","title":"FindOne"},{"location":"api-documentation/query/#findoneproject","text":"| project ( projection_model : Optional [ Type [ FindQueryProjectionType ]] = None ) -> Union [ | \"FindOne[FindQueryResultType]\" , \"FindOne[FindQueryProjectionType]\" | ] Apply projection parameter Arguments : projection_model : Optional[Type[BaseModel]] - projection model Returns : self","title":"FindOne.project"},{"location":"api-documentation/query/#findonefind_one","text":"| find_one ( * args : Union [ Mapping [ str , Any ], bool ], * , projection_model : Optional [ Type [ FindQueryProjectionType ]] = None , session : Optional [ ClientSession ] = None , ignore_cache : bool = False ) -> Union [ | \"FindOne[FindQueryResultType]\" , \"FindOne[FindQueryProjectionType]\" | ] Find one document by criteria Arguments : args : *Mapping[str, Any] - search criteria projection_model : Optional[Type[BaseModel]] - projection model session : Optional[ClientSession] - pymongo session ignore_cache : bool Returns : FindOne - query instance","title":"FindOne.find_one"},{"location":"api-documentation/query/#findoneupdate_one","text":"| update_one ( * args : Mapping [ str , Any ], * , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> UpdateOne Create UpdateOne query using modifications and provide search criteria there Arguments : args : *Mapping[str,Any] - the modifications to apply session : Optional[ClientSession] - PyMongo sessions Returns : UpdateOne query","title":"FindOne.update_one"},{"location":"api-documentation/query/#findonedelete_one","text":"| delete_one ( session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> DeleteOne Provide search criteria to the DeleteOne query Arguments : session : Optional[ClientSession] - PyMongo sessions Returns : DeleteOne query","title":"FindOne.delete_one"},{"location":"api-documentation/query/#findonereplace_one","text":"| async replace_one ( document : \"DocType\" , session : Optional [ ClientSession ] = None , bulk_writer : Optional [ BulkWriter ] = None ) -> Optional [ UpdateResult ] Replace found document by provided Arguments : document : Document - document, which will replace the found one session : Optional[ClientSession] - PyMongo session bulk_writer : Optional[BulkWriter] - Beanie bulk writer Returns : UpdateResult","title":"FindOne.replace_one"},{"location":"api-documentation/query/#findone__await__","text":"| __await__ () -> Generator [ Coroutine , Any , Optional [ FindQueryResultType ]] Run the query Returns : BaseModel","title":"FindOne.__await__"},{"location":"api-documentation/query/#beanieodmqueriescursor","text":"","title":"beanie.odm.queries.cursor"},{"location":"api-documentation/query/#basecursorquery","text":"class BaseCursorQuery ( Generic [ CursorResultType ]) BaseCursorQuery class. Wrapper over AsyncIOMotorCursor, which parse result with model","title":"BaseCursorQuery"},{"location":"api-documentation/query/#basecursorqueryto_list","text":"| async to_list ( length : Optional [ int ] = None ) -> List [ CursorResultType ] Get list of documents Arguments : length : Optional[int] - length of the list Returns : Union[List[BaseModel], List[Dict[str, Any]]]","title":"BaseCursorQuery.to_list"},{"location":"api-documentation/query/#beanieodmqueriesaggregation","text":"","title":"beanie.odm.queries.aggregation"},{"location":"api-documentation/query/#aggregationquery","text":"class AggregationQuery ( Generic [ AggregationProjectionType ], BaseCursorQuery [ AggregationProjectionType ], SessionMethods ) Aggregation Query Inherited from: SessionMethods - session methods BaseCursorQuery - async generator","title":"AggregationQuery"},{"location":"api-documentation/query/#beanieodmqueriesdelete","text":"","title":"beanie.odm.queries.delete"},{"location":"api-documentation/query/#deletequery","text":"class DeleteQuery ( SessionMethods ) Deletion Query","title":"DeleteQuery"},{"location":"api-documentation/query/#deletemany","text":"class DeleteMany ( DeleteQuery )","title":"DeleteMany"},{"location":"api-documentation/query/#deletemany__await__","text":"| __await__ () -> Generator [ DeleteResult , None , None ] Run the query Returns :","title":"DeleteMany.__await__"},{"location":"api-documentation/query/#deleteone","text":"class DeleteOne ( DeleteQuery )","title":"DeleteOne"},{"location":"api-documentation/query/#deleteone__await__","text":"| __await__ () -> Generator [ DeleteResult , None , None ] Run the query Returns :","title":"DeleteOne.__await__"},{"location":"api-documentation/operators/find/","text":"beanie.odm.operators.find.element Exists class Exists ( BaseFindElementOperator ) $exists query operator Example : class Product ( Document ): price : float Exists ( Product . price , True ) Will return query object like { \"price\" : { \"$exists\" : True }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/exists/ Type class Type ( BaseFindElementOperator ) $type query operator Example : class Product ( Document ): price : float Type ( Product . price , \"decimal\" ) Will return query object like { \"price\" : { \"$type\" : \"decimal\" }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/type/ beanie.odm.operators.find.array All class All ( BaseFindArrayOperator ) $all array query operator Example : class Sample ( Document ): results : List [ int ] All ( Sample . results , [ 80 , 85 ]) Will return query object like { \"results\" : { \"$all\" : [ 80 , 85 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/all ElemMatch class ElemMatch ( BaseFindArrayOperator ) $elemMatch array query operator Example : class Sample ( Document ): results : List [ int ] ElemMatch ( Sample . results , [ 80 , 85 ]) Will return query object like { \"results\" : { \"$elemMatch\" : [ 80 , 85 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/elemMatch/ Size class Size ( BaseFindArrayOperator ) $size array query operator Example : class Sample ( Document ): results : List [ int ] Size ( Sample . results , 2 ) Will return query object like { \"results\" : { \"$size\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/size/ beanie.odm.operators.find.logical Or class Or ( LogicalOperatorForListOfExpressions ) $or query operator Example : class Product ( Document ): price : float category : str Or ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$or\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/or/ And class And ( LogicalOperatorForListOfExpressions ) $and query operator Example : class Product ( Document ): price : float category : str And ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$and\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/and/ Nor class Nor ( BaseFindLogicalOperator ) $nor query operator Example : class Product ( Document ): price : float category : str Nor ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$nor\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nor/ Not class Not ( BaseFindLogicalOperator ) $not query operator Example : class Product ( Document ): price : float category : str Not ({ Product . price < 10 }) Will return query object like { \"$not\" : { \"price\" : { \"$lt\" : 10 }}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/not/ beanie.odm.operators.find.geospatial GeoIntersects class GeoIntersects ( BaseFindGeospatialOperator ) $geoIntersects query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] GeoIntersects ( Place . geo , \"Polygon\" , [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]]) Will return query object like { \"geo\" : { \"$geoIntersects\" : { \"$geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]], } } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/geoIntersects/ GeoWithin class GeoWithin ( BaseFindGeospatialOperator ) $geoWithin query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] GeoWithin ( Place . geo , \"Polygon\" , [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]]) Will return query object like { \"geo\" : { \"$geoWithin\" : { \"$geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]], } } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/ Near class Near ( BaseFindGeospatialOperator ) $near query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] Near ( Place . geo , 1.2345 , 2.3456 , min_distance = 500 ) Will return query object like { \"geo\" : { \"$near\" : { \"$geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 1.2345 , 2.3456 ], }, \"$maxDistance\" : 500 , } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/near/ NearSphere class NearSphere ( Near ) $nearSphere query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] NearSphere ( Place . geo , 1.2345 , 2.3456 , min_distance = 500 ) Will return query object like { \"geo\" : { \"$nearSphere\" : { \"$geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 1.2345 , 2.3456 ], }, \"$maxDistance\" : 500 , } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nearSphere/ beanie.odm.operators.find.evaluation Expr class Expr ( BaseFindEvaluationOperator ) $type query operator Example : class Sample ( Document ): one : int two : int Expr ({ \"$gt\" : [ \"$one\" , \"$two\" ]}) Will return query object like { \"$expr\" : { \"$gt\" : [ \"$one\" , \"$two\" ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/expr/ JsonSchema class JsonSchema ( BaseFindEvaluationOperator ) $jsonSchema query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/ Mod class Mod ( BaseFindEvaluationOperator ) $mod query operator Example : class Sample ( Document ): one : int Mod ( Sample . one , 4 , 0 ) Will return query object like { \"one\" : { \"$mod\" : [ 4 , 0 ] } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/mod/ RegEx class RegEx ( BaseFindEvaluationOperator ) $regex query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/regex/ Text class Text ( BaseFindEvaluationOperator ) $text query operator Example : class Sample ( Document ): description : Indexed ( str , pymongo . TEXT ) Text ( \"coffee\" ) Will return query object like { \"$text\" : { \"$search\" : \"coffee\" , \"$caseSensitive\" : False , \"$diacriticSensitive\" : False } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/text/ Text.__init__ | __init__ ( search : str , language : Optional [ str ] = None , case_sensitive : bool = False , diacritic_sensitive : bool = False ) Arguments : search : str language : Optional[str] = None case_sensitive : bool = False diacritic_sensitive : bool = False Where class Where ( BaseFindEvaluationOperator ) $where query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/where/ beanie.odm.operators.find.bitwise BitsAllClear class BitsAllClear ( BaseFindBitwiseOperator ) $bitsAllClear query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllClear/ BitsAllSet class BitsAllSet ( BaseFindBitwiseOperator ) $bitsAllSet query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllSet/ BitsAnyClear class BitsAnyClear ( BaseFindBitwiseOperator ) $bitsAnyClear query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnyClear/ BitsAnySet class BitsAnySet ( BaseFindBitwiseOperator ) $bitsAnySet query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnySet/ beanie.odm.operators.find.comparison Eq class Eq ( BaseFindComparisonOperator ) equal query operator Example : class Product ( Document ): price : float Eq ( Product . price , 2 ) Will return query object like { \"price\" : 2 } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/eq/ GT class GT ( BaseFindComparisonOperator ) $gt query operator Example : class Product ( Document ): price : float GT ( Product . price , 2 ) Will return query object like { \"price\" : { \"$gt\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/gt/ GTE class GTE ( BaseFindComparisonOperator ) $gte query operator Example : class Product ( Document ): price : float GTE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$gte\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/gte/ In class In ( BaseFindComparisonOperator ) $in query operator Example : class Product ( Document ): price : float In ( Product . price , [ 2 , 3 , 4 ]) Will return query object like { \"price\" : { \"$in\" : [ 2 , 3 , 4 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/in/ NotIn class NotIn ( BaseFindComparisonOperator ) $nin query operator Example : class Product ( Document ): price : float NotIn ( Product . price , [ 2 , 3 , 4 ]) Will return query object like { \"price\" : { \"$nin\" : [ 2 , 3 , 4 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nin/ LT class LT ( BaseFindComparisonOperator ) $lt query operator Example : class Product ( Document ): price : float LT ( Product . price , 2 ) Will return query object like { \"price\" : { \"$lt\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/lt/ LTE class LTE ( BaseFindComparisonOperator ) $lte query operator Example : class Product ( Document ): price : float LTE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$lte\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/lte/ NE class NE ( BaseFindComparisonOperator ) $ne query operator Example : class Product ( Document ): price : float NE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$ne\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/ne/","title":"Find"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindelement","text":"","title":"beanie.odm.operators.find.element"},{"location":"api-documentation/operators/find/#exists","text":"class Exists ( BaseFindElementOperator ) $exists query operator Example : class Product ( Document ): price : float Exists ( Product . price , True ) Will return query object like { \"price\" : { \"$exists\" : True }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/exists/","title":"Exists"},{"location":"api-documentation/operators/find/#type","text":"class Type ( BaseFindElementOperator ) $type query operator Example : class Product ( Document ): price : float Type ( Product . price , \"decimal\" ) Will return query object like { \"price\" : { \"$type\" : \"decimal\" }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/type/","title":"Type"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindarray","text":"","title":"beanie.odm.operators.find.array"},{"location":"api-documentation/operators/find/#all","text":"class All ( BaseFindArrayOperator ) $all array query operator Example : class Sample ( Document ): results : List [ int ] All ( Sample . results , [ 80 , 85 ]) Will return query object like { \"results\" : { \"$all\" : [ 80 , 85 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/all","title":"All"},{"location":"api-documentation/operators/find/#elemmatch","text":"class ElemMatch ( BaseFindArrayOperator ) $elemMatch array query operator Example : class Sample ( Document ): results : List [ int ] ElemMatch ( Sample . results , [ 80 , 85 ]) Will return query object like { \"results\" : { \"$elemMatch\" : [ 80 , 85 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/elemMatch/","title":"ElemMatch"},{"location":"api-documentation/operators/find/#size","text":"class Size ( BaseFindArrayOperator ) $size array query operator Example : class Sample ( Document ): results : List [ int ] Size ( Sample . results , 2 ) Will return query object like { \"results\" : { \"$size\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/size/","title":"Size"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindlogical","text":"","title":"beanie.odm.operators.find.logical"},{"location":"api-documentation/operators/find/#or","text":"class Or ( LogicalOperatorForListOfExpressions ) $or query operator Example : class Product ( Document ): price : float category : str Or ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$or\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/or/","title":"Or"},{"location":"api-documentation/operators/find/#and","text":"class And ( LogicalOperatorForListOfExpressions ) $and query operator Example : class Product ( Document ): price : float category : str And ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$and\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/and/","title":"And"},{"location":"api-documentation/operators/find/#nor","text":"class Nor ( BaseFindLogicalOperator ) $nor query operator Example : class Product ( Document ): price : float category : str Nor ({ Product . price < 10 }, { Product . category == \"Sweets\" }) Will return query object like { \"$nor\" : [{ \"price\" : { \"$lt\" : 10 }}, { \"category\" : \"Sweets\" }]} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nor/","title":"Nor"},{"location":"api-documentation/operators/find/#not","text":"class Not ( BaseFindLogicalOperator ) $not query operator Example : class Product ( Document ): price : float category : str Not ({ Product . price < 10 }) Will return query object like { \"$not\" : { \"price\" : { \"$lt\" : 10 }}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/not/","title":"Not"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindgeospatial","text":"","title":"beanie.odm.operators.find.geospatial"},{"location":"api-documentation/operators/find/#geointersects","text":"class GeoIntersects ( BaseFindGeospatialOperator ) $geoIntersects query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] GeoIntersects ( Place . geo , \"Polygon\" , [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]]) Will return query object like { \"geo\" : { \"$geoIntersects\" : { \"$geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]], } } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/geoIntersects/","title":"GeoIntersects"},{"location":"api-documentation/operators/find/#geowithin","text":"class GeoWithin ( BaseFindGeospatialOperator ) $geoWithin query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] GeoWithin ( Place . geo , \"Polygon\" , [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]]) Will return query object like { \"geo\" : { \"$geoWithin\" : { \"$geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [[ 0 , 0 ], [ 1 , 1 ], [ 3 , 3 ]], } } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/","title":"GeoWithin"},{"location":"api-documentation/operators/find/#near","text":"class Near ( BaseFindGeospatialOperator ) $near query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] Near ( Place . geo , 1.2345 , 2.3456 , min_distance = 500 ) Will return query object like { \"geo\" : { \"$near\" : { \"$geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 1.2345 , 2.3456 ], }, \"$maxDistance\" : 500 , } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/near/","title":"Near"},{"location":"api-documentation/operators/find/#nearsphere","text":"class NearSphere ( Near ) $nearSphere query operator Example : class GeoObject ( BaseModel ): type : str = \"Point\" coordinates : Tuple [ float , float ] class Place ( Document ): geo : GeoObject class Collection : name = \"places\" indexes = [ [( \"geo\" , pymongo . GEOSPHERE )], # GEO index ] NearSphere ( Place . geo , 1.2345 , 2.3456 , min_distance = 500 ) Will return query object like { \"geo\" : { \"$nearSphere\" : { \"$geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 1.2345 , 2.3456 ], }, \"$maxDistance\" : 500 , } } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nearSphere/","title":"NearSphere"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindevaluation","text":"","title":"beanie.odm.operators.find.evaluation"},{"location":"api-documentation/operators/find/#expr","text":"class Expr ( BaseFindEvaluationOperator ) $type query operator Example : class Sample ( Document ): one : int two : int Expr ({ \"$gt\" : [ \"$one\" , \"$two\" ]}) Will return query object like { \"$expr\" : { \"$gt\" : [ \"$one\" , \"$two\" ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/expr/","title":"Expr"},{"location":"api-documentation/operators/find/#jsonschema","text":"class JsonSchema ( BaseFindEvaluationOperator ) $jsonSchema query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/","title":"JsonSchema"},{"location":"api-documentation/operators/find/#mod","text":"class Mod ( BaseFindEvaluationOperator ) $mod query operator Example : class Sample ( Document ): one : int Mod ( Sample . one , 4 , 0 ) Will return query object like { \"one\" : { \"$mod\" : [ 4 , 0 ] } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/mod/","title":"Mod"},{"location":"api-documentation/operators/find/#regex","text":"class RegEx ( BaseFindEvaluationOperator ) $regex query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/regex/","title":"RegEx"},{"location":"api-documentation/operators/find/#text","text":"class Text ( BaseFindEvaluationOperator ) $text query operator Example : class Sample ( Document ): description : Indexed ( str , pymongo . TEXT ) Text ( \"coffee\" ) Will return query object like { \"$text\" : { \"$search\" : \"coffee\" , \"$caseSensitive\" : False , \"$diacriticSensitive\" : False } } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/text/","title":"Text"},{"location":"api-documentation/operators/find/#text__init__","text":"| __init__ ( search : str , language : Optional [ str ] = None , case_sensitive : bool = False , diacritic_sensitive : bool = False ) Arguments : search : str language : Optional[str] = None case_sensitive : bool = False diacritic_sensitive : bool = False","title":"Text.__init__"},{"location":"api-documentation/operators/find/#where","text":"class Where ( BaseFindEvaluationOperator ) $where query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/where/","title":"Where"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindbitwise","text":"","title":"beanie.odm.operators.find.bitwise"},{"location":"api-documentation/operators/find/#bitsallclear","text":"class BitsAllClear ( BaseFindBitwiseOperator ) $bitsAllClear query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllClear/","title":"BitsAllClear"},{"location":"api-documentation/operators/find/#bitsallset","text":"class BitsAllSet ( BaseFindBitwiseOperator ) $bitsAllSet query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAllSet/","title":"BitsAllSet"},{"location":"api-documentation/operators/find/#bitsanyclear","text":"class BitsAnyClear ( BaseFindBitwiseOperator ) $bitsAnyClear query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnyClear/","title":"BitsAnyClear"},{"location":"api-documentation/operators/find/#bitsanyset","text":"class BitsAnySet ( BaseFindBitwiseOperator ) $bitsAnySet query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/bitsAnySet/","title":"BitsAnySet"},{"location":"api-documentation/operators/find/#beanieodmoperatorsfindcomparison","text":"","title":"beanie.odm.operators.find.comparison"},{"location":"api-documentation/operators/find/#eq","text":"class Eq ( BaseFindComparisonOperator ) equal query operator Example : class Product ( Document ): price : float Eq ( Product . price , 2 ) Will return query object like { \"price\" : 2 } MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/eq/","title":"Eq"},{"location":"api-documentation/operators/find/#gt","text":"class GT ( BaseFindComparisonOperator ) $gt query operator Example : class Product ( Document ): price : float GT ( Product . price , 2 ) Will return query object like { \"price\" : { \"$gt\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/gt/","title":"GT"},{"location":"api-documentation/operators/find/#gte","text":"class GTE ( BaseFindComparisonOperator ) $gte query operator Example : class Product ( Document ): price : float GTE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$gte\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/gte/","title":"GTE"},{"location":"api-documentation/operators/find/#in","text":"class In ( BaseFindComparisonOperator ) $in query operator Example : class Product ( Document ): price : float In ( Product . price , [ 2 , 3 , 4 ]) Will return query object like { \"price\" : { \"$in\" : [ 2 , 3 , 4 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/in/","title":"In"},{"location":"api-documentation/operators/find/#notin","text":"class NotIn ( BaseFindComparisonOperator ) $nin query operator Example : class Product ( Document ): price : float NotIn ( Product . price , [ 2 , 3 , 4 ]) Will return query object like { \"price\" : { \"$nin\" : [ 2 , 3 , 4 ]}} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/nin/","title":"NotIn"},{"location":"api-documentation/operators/find/#lt","text":"class LT ( BaseFindComparisonOperator ) $lt query operator Example : class Product ( Document ): price : float LT ( Product . price , 2 ) Will return query object like { \"price\" : { \"$lt\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/lt/","title":"LT"},{"location":"api-documentation/operators/find/#lte","text":"class LTE ( BaseFindComparisonOperator ) $lte query operator Example : class Product ( Document ): price : float LTE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$lte\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/lte/","title":"LTE"},{"location":"api-documentation/operators/find/#ne","text":"class NE ( BaseFindComparisonOperator ) $ne query operator Example : class Product ( Document ): price : float NE ( Product . price , 2 ) Will return query object like { \"price\" : { \"$ne\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/query/ne/","title":"NE"},{"location":"api-documentation/operators/update/","text":"beanie.odm.operators.update.general Set class Set ( BaseUpdateGeneralOperator ) $set update query operator Example : class Sample ( Document ): one : int Set ({ Sample . one , 2 }) Will return query object like { \"$set\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/set/ CurrentDate class CurrentDate ( BaseUpdateGeneralOperator ) $currentDate update query operator Example : class Sample ( Document ): ts : datetime CurrentDate ({ Sample . ts , True }) Will return query object like { \"$currentDate\" : { \"ts\" : True }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/currentDate/ Inc class Inc ( BaseUpdateGeneralOperator ) $inc update query operator Example : class Sample ( Document ): one : int Inc ({ Sample . one , 2 }) Will return query object like { \"$inc\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/inc/ Min class Min ( BaseUpdateGeneralOperator ) $min update query operator Example : class Sample ( Document ): one : int Min ({ Sample . one , 2 }) Will return query object like { \"$min\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/min/ Max class Max ( BaseUpdateGeneralOperator ) $max update query operator Example : class Sample ( Document ): one : int Max ({ Sample . one , 2 }) Will return query object like { \"$max\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/max/ Mul class Mul ( BaseUpdateGeneralOperator ) $mul update query operator Example : class Sample ( Document ): one : int Mul ({ Sample . one , 2 }) Will return query object like { \"$mul\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/mul/ Rename class Rename ( BaseUpdateGeneralOperator ) $rename update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/rename/ SetOnInsert class SetOnInsert ( BaseUpdateGeneralOperator ) $setOnInsert update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/ Unset class Unset ( BaseUpdateGeneralOperator ) $unset update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/unset/ beanie.odm.operators.update.array AddToSet class AddToSet ( BaseUpdateArrayOperator ) $addToSet update array query operator Example : class Sample ( Document ): results : List [ int ] AddToSet ({ Sample . results , 2 }) Will return query object like { \"$addToSet\" : { \"results\" : 2 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/addToSet/ Pop class Pop ( BaseUpdateArrayOperator ) $pop update array query operator Example : class Sample ( Document ): results : List [ int ] Pop ({ Sample . results , 2 }) Will return query object like { \"$pop\" : { \"results\" : - 1 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pop/ Pull class Pull ( BaseUpdateArrayOperator ) $pull update array query operator Example : class Sample ( Document ): results : List [ int ] Pull ( In ( Sample . result , [ 1 , 2 , 3 , 4 , 5 ]) Will return query object like { \"$pull\" : { \"results\" : { $ in : [ 1 , 2 , 3 , 4 , 5 ] }}} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pull/ Push class Push ( BaseUpdateArrayOperator ) $push update array query operator Example : class Sample ( Document ): results : List [ int ] Push ({ Sample . results : 1 }) Will return query object like { \"$push\" : { \"results\" : 1 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/push/ PullAll class PullAll ( BaseUpdateArrayOperator ) $pullAll update array query operator Example : class Sample ( Document ): results : List [ int ] PullAll ({ Sample . results : [ 0 , 5 ] }) Will return query object like { \"$pullAll\" : { \"results\" : [ 0 , 5 ] }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pullAll/ beanie.odm.operators.update.bitwise Bit class Bit ( BaseUpdateBitwiseOperator ) $bit update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/bit/","title":"Update"},{"location":"api-documentation/operators/update/#beanieodmoperatorsupdategeneral","text":"","title":"beanie.odm.operators.update.general"},{"location":"api-documentation/operators/update/#set","text":"class Set ( BaseUpdateGeneralOperator ) $set update query operator Example : class Sample ( Document ): one : int Set ({ Sample . one , 2 }) Will return query object like { \"$set\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/set/","title":"Set"},{"location":"api-documentation/operators/update/#currentdate","text":"class CurrentDate ( BaseUpdateGeneralOperator ) $currentDate update query operator Example : class Sample ( Document ): ts : datetime CurrentDate ({ Sample . ts , True }) Will return query object like { \"$currentDate\" : { \"ts\" : True }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/currentDate/","title":"CurrentDate"},{"location":"api-documentation/operators/update/#inc","text":"class Inc ( BaseUpdateGeneralOperator ) $inc update query operator Example : class Sample ( Document ): one : int Inc ({ Sample . one , 2 }) Will return query object like { \"$inc\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/inc/","title":"Inc"},{"location":"api-documentation/operators/update/#min","text":"class Min ( BaseUpdateGeneralOperator ) $min update query operator Example : class Sample ( Document ): one : int Min ({ Sample . one , 2 }) Will return query object like { \"$min\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/min/","title":"Min"},{"location":"api-documentation/operators/update/#max","text":"class Max ( BaseUpdateGeneralOperator ) $max update query operator Example : class Sample ( Document ): one : int Max ({ Sample . one , 2 }) Will return query object like { \"$max\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/max/","title":"Max"},{"location":"api-documentation/operators/update/#mul","text":"class Mul ( BaseUpdateGeneralOperator ) $mul update query operator Example : class Sample ( Document ): one : int Mul ({ Sample . one , 2 }) Will return query object like { \"$mul\" : { \"one\" : 2 }} MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/mul/","title":"Mul"},{"location":"api-documentation/operators/update/#rename","text":"class Rename ( BaseUpdateGeneralOperator ) $rename update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/rename/","title":"Rename"},{"location":"api-documentation/operators/update/#setoninsert","text":"class SetOnInsert ( BaseUpdateGeneralOperator ) $setOnInsert update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/","title":"SetOnInsert"},{"location":"api-documentation/operators/update/#unset","text":"class Unset ( BaseUpdateGeneralOperator ) $unset update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/unset/","title":"Unset"},{"location":"api-documentation/operators/update/#beanieodmoperatorsupdatearray","text":"","title":"beanie.odm.operators.update.array"},{"location":"api-documentation/operators/update/#addtoset","text":"class AddToSet ( BaseUpdateArrayOperator ) $addToSet update array query operator Example : class Sample ( Document ): results : List [ int ] AddToSet ({ Sample . results , 2 }) Will return query object like { \"$addToSet\" : { \"results\" : 2 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/addToSet/","title":"AddToSet"},{"location":"api-documentation/operators/update/#pop","text":"class Pop ( BaseUpdateArrayOperator ) $pop update array query operator Example : class Sample ( Document ): results : List [ int ] Pop ({ Sample . results , 2 }) Will return query object like { \"$pop\" : { \"results\" : - 1 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pop/","title":"Pop"},{"location":"api-documentation/operators/update/#pull","text":"class Pull ( BaseUpdateArrayOperator ) $pull update array query operator Example : class Sample ( Document ): results : List [ int ] Pull ( In ( Sample . result , [ 1 , 2 , 3 , 4 , 5 ]) Will return query object like { \"$pull\" : { \"results\" : { $ in : [ 1 , 2 , 3 , 4 , 5 ] }}} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pull/","title":"Pull"},{"location":"api-documentation/operators/update/#push","text":"class Push ( BaseUpdateArrayOperator ) $push update array query operator Example : class Sample ( Document ): results : List [ int ] Push ({ Sample . results : 1 }) Will return query object like { \"$push\" : { \"results\" : 1 }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/push/","title":"Push"},{"location":"api-documentation/operators/update/#pullall","text":"class PullAll ( BaseUpdateArrayOperator ) $pullAll update array query operator Example : class Sample ( Document ): results : List [ int ] PullAll ({ Sample . results : [ 0 , 5 ] }) Will return query object like { \"$pullAll\" : { \"results\" : [ 0 , 5 ] }} MongoDB docs: https://docs.mongodb.com/manual/reference/operator/update/pullAll/","title":"PullAll"},{"location":"api-documentation/operators/update/#beanieodmoperatorsupdatebitwise","text":"","title":"beanie.odm.operators.update.bitwise"},{"location":"api-documentation/operators/update/#bit","text":"class Bit ( BaseUpdateBitwiseOperator ) $bit update query operator MongoDB doc: https://docs.mongodb.com/manual/reference/operator/update/bit/","title":"Bit"},{"location":"tutorial/aggregation/","text":"Aggregations You can perform aggregation queries through beanie as well. For example, to calculate the average: # With a search: avg_price = await Product . find ( Product . category . name == \"Chocolate\" ) . avg ( Product . price ) # Over the whole collection: ``` python avg_price = await Product . avg ( Product . price ) A full list of avalible methods can be found here . You can also use the native PyMongo syntax by calling the aggregate method. However, as Beanie will not know what output to expect you will have to supply a projection model yourself. If you do not supply a projection model then a dictionarie will be returned. class OutputItem ( BaseModel ): id : str = Field ( None , alias = \"_id\" ) total : float result = await Product . find ( Product . category . name == \"Chocolate\" ) . aggregate ( [{ \"$group\" : { \"_id\" : \"$category.name\" , \"total\" : { \"$avg\" : \"$price\" }}}], projection_model = OutputItem ) . to_list ()","title":"Aggregation"},{"location":"tutorial/aggregation/#aggregations","text":"You can perform aggregation queries through beanie as well. For example, to calculate the average: # With a search: avg_price = await Product . find ( Product . category . name == \"Chocolate\" ) . avg ( Product . price ) # Over the whole collection: ``` python avg_price = await Product . avg ( Product . price ) A full list of avalible methods can be found here . You can also use the native PyMongo syntax by calling the aggregate method. However, as Beanie will not know what output to expect you will have to supply a projection model yourself. If you do not supply a projection model then a dictionarie will be returned. class OutputItem ( BaseModel ): id : str = Field ( None , alias = \"_id\" ) total : float result = await Product . find ( Product . category . name == \"Chocolate\" ) . aggregate ( [{ \"$group\" : { \"_id\" : \"$category.name\" , \"total\" : { \"$avg\" : \"$price\" }}}], projection_model = OutputItem ) . to_list ()","title":"Aggregations"},{"location":"tutorial/defining-a-document/","text":"Defining a document The Document class in Beanie is responsible for mapping and handling the data from the collection. It is inherited from the BaseModel Pydantic class, so it follows the same data typing and parsing behavior. import pymongo from typing import Optional from pydantic import BaseModel from beanie import Document from beanie import Indexed class Category ( BaseModel ): name : str description : str class Product ( Document ): # This is the model name : str description : Optional [ str ] = None price : Indexed ( float , pymongo . DESCENDING ) category : Category class Collection : name = \"products\" indexes = [ [ ( \"name\" , pymongo . TEXT ), ( \"description\" , pymongo . TEXT ), ], ] The 'id' field Each Document has a id field. The id field reflects the unique _id field of the MongoDB document. Each object of the Document type has this field, and it is always set if a document is present in the database. The default type of this field is PydanticObjectId . class Sample ( Document ): # the id field does not need to be declared explcitly num : int description : str # query a single object from the database foo = await Sample . find_one ( Sample . num > 5 ) print ( foo . id ) # This will print the id You can reference other objects using their id, for example if you want to list Sample ids: class ReferencesSample ( Document ): name : str mysamples : List [ PydanticObjectId ] If you prefer another type, then you can overide the default. For example, to set it to UUID: from pydantic import Field from uuid import UUID , uuid4 class Sample ( Document ): id : UUID = Field ( default_factory = uuid4 ) num : int description : str","title":"Defining a document"},{"location":"tutorial/defining-a-document/#defining-a-document","text":"The Document class in Beanie is responsible for mapping and handling the data from the collection. It is inherited from the BaseModel Pydantic class, so it follows the same data typing and parsing behavior. import pymongo from typing import Optional from pydantic import BaseModel from beanie import Document from beanie import Indexed class Category ( BaseModel ): name : str description : str class Product ( Document ): # This is the model name : str description : Optional [ str ] = None price : Indexed ( float , pymongo . DESCENDING ) category : Category class Collection : name = \"products\" indexes = [ [ ( \"name\" , pymongo . TEXT ), ( \"description\" , pymongo . TEXT ), ], ]","title":"Defining a document"},{"location":"tutorial/defining-a-document/#the-id-field","text":"Each Document has a id field. The id field reflects the unique _id field of the MongoDB document. Each object of the Document type has this field, and it is always set if a document is present in the database. The default type of this field is PydanticObjectId . class Sample ( Document ): # the id field does not need to be declared explcitly num : int description : str # query a single object from the database foo = await Sample . find_one ( Sample . num > 5 ) print ( foo . id ) # This will print the id You can reference other objects using their id, for example if you want to list Sample ids: class ReferencesSample ( Document ): name : str mysamples : List [ PydanticObjectId ] If you prefer another type, then you can overide the default. For example, to set it to UUID: from pydantic import Field from uuid import UUID , uuid4 class Sample ( Document ): id : UUID = Field ( default_factory = uuid4 ) num : int description : str","title":"The 'id' field"},{"location":"tutorial/finding-documents/","text":"To populate the database, please run the examples from the previous section of the tutorial as we will be using the same setup here. Finding documents The basic syntax for finding multiple documents in the database is to call the classmethod find() or it's synonym find_many() with some search criteria (see next section): findresult = Product . find ( search_criteria ) This returns a FindMany object which can be used to access the results in multiple ways. To loop through the results, use a async for loop\" async for result in Product . find ( search_criteria ): print ( result ) If you prefer a list of the results then you can call to_list() : result = await Product . find ( search_criteria ) . to_list () Search criteria As search criteria, Beanie supports python-based syntax. For comparisons Python comparison operators can be used on the class fields (and nested fields): products = await Product . find ( Product . price < 10 ) . to_list () This is supported for the operators: == , > , >= , < , <= , != . Other MongoDB query operators can be used with the included wrappers. For example the $in operator can be used as follows: from beanie.operators import In products = await Product . find ( In ( Product . category . name , [ \"Chocolate\" , \"Fruits\" ])) . to_list () The whole list of the find query operators can be found here . For more complex cases native PyMongo syntax is also supported: products = await Product . find ({ \"price\" : 1000 }) . to_list () Finding single documents Sometimes you will only need to find a single document. If you are searching by id then you can use the get method: bar = await Product . get ( \"608da169eb9e17281f0ab2ff\" ) To find a single document via a searching criteria you can use the find_one method: bar = await Product . find_one ( Product . name == \"Peanut Bar\" ) More complex queries Multiple search criteria If you have multiple search criteria to search for you can list them as separate arguments to any of the find functions: chocolates = await Product . find ( Product . category . name == \"Chocolate\" , Product . price < 5 ) . to_list () Alternatively, you can chain find methods: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . find ( Product . price < 5 ) . to_list () Sorting Sorting can be done with the sort method. You can pass it one or multiple fields to sort by. You may optionally specify a + or - (denoting ascending and descending respectively). chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( - Product . price , + Product . name ) . to_list () You can also specify fields as strings or as tuples: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( \"-price\" , \"+name\" ) . to_list () chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( [ ( Product . price , pymongo . DESCENDING ), ( Product . name , pymongo . ASCENDING ), ] ) . to_list () Skip and limit To skip a certain number of documents, or limit the total number of elements returned, the skip and limit methods can be used: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . skip ( 2 ) . to_list () chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . limit ( 2 ) . to_list () Projections When only part of a document is required projections can save a lot of database bandwidth and processing. For simple projections we can just define a pydantic model with the required fields and pass it to project() : class ProductShortView ( BaseModel ): name : str price : float chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . project ( ProductShortView ) . to_list () For more complex projections an inner Settings class with a projection field can be added: class ProductView ( BaseModel ): name : str category : str class Settings : projection = { \"name\" : 1 , \"category\" : \"$category.name\" } chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . project ( ProductView ) . to_list () Finding all documents If you every want to find all documents you can use the find_all() classmethod. This is equivalent to find({}) .","title":"Finding documents"},{"location":"tutorial/finding-documents/#finding-documents","text":"The basic syntax for finding multiple documents in the database is to call the classmethod find() or it's synonym find_many() with some search criteria (see next section): findresult = Product . find ( search_criteria ) This returns a FindMany object which can be used to access the results in multiple ways. To loop through the results, use a async for loop\" async for result in Product . find ( search_criteria ): print ( result ) If you prefer a list of the results then you can call to_list() : result = await Product . find ( search_criteria ) . to_list ()","title":"Finding documents"},{"location":"tutorial/finding-documents/#search-criteria","text":"As search criteria, Beanie supports python-based syntax. For comparisons Python comparison operators can be used on the class fields (and nested fields): products = await Product . find ( Product . price < 10 ) . to_list () This is supported for the operators: == , > , >= , < , <= , != . Other MongoDB query operators can be used with the included wrappers. For example the $in operator can be used as follows: from beanie.operators import In products = await Product . find ( In ( Product . category . name , [ \"Chocolate\" , \"Fruits\" ])) . to_list () The whole list of the find query operators can be found here . For more complex cases native PyMongo syntax is also supported: products = await Product . find ({ \"price\" : 1000 }) . to_list ()","title":"Search criteria"},{"location":"tutorial/finding-documents/#finding-single-documents","text":"Sometimes you will only need to find a single document. If you are searching by id then you can use the get method: bar = await Product . get ( \"608da169eb9e17281f0ab2ff\" ) To find a single document via a searching criteria you can use the find_one method: bar = await Product . find_one ( Product . name == \"Peanut Bar\" )","title":"Finding single documents"},{"location":"tutorial/finding-documents/#more-complex-queries","text":"","title":"More complex queries"},{"location":"tutorial/finding-documents/#multiple-search-criteria","text":"If you have multiple search criteria to search for you can list them as separate arguments to any of the find functions: chocolates = await Product . find ( Product . category . name == \"Chocolate\" , Product . price < 5 ) . to_list () Alternatively, you can chain find methods: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . find ( Product . price < 5 ) . to_list ()","title":"Multiple search criteria"},{"location":"tutorial/finding-documents/#sorting","text":"Sorting can be done with the sort method. You can pass it one or multiple fields to sort by. You may optionally specify a + or - (denoting ascending and descending respectively). chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( - Product . price , + Product . name ) . to_list () You can also specify fields as strings or as tuples: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( \"-price\" , \"+name\" ) . to_list () chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . sort ( [ ( Product . price , pymongo . DESCENDING ), ( Product . name , pymongo . ASCENDING ), ] ) . to_list ()","title":"Sorting"},{"location":"tutorial/finding-documents/#skip-and-limit","text":"To skip a certain number of documents, or limit the total number of elements returned, the skip and limit methods can be used: chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . skip ( 2 ) . to_list () chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . limit ( 2 ) . to_list ()","title":"Skip and limit"},{"location":"tutorial/finding-documents/#projections","text":"When only part of a document is required projections can save a lot of database bandwidth and processing. For simple projections we can just define a pydantic model with the required fields and pass it to project() : class ProductShortView ( BaseModel ): name : str price : float chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . project ( ProductShortView ) . to_list () For more complex projections an inner Settings class with a projection field can be added: class ProductView ( BaseModel ): name : str category : str class Settings : projection = { \"name\" : 1 , \"category\" : \"$category.name\" } chocolates = await Product . find ( Product . category . name == \"Chocolate\" ) . project ( ProductView ) . to_list ()","title":"Projections"},{"location":"tutorial/finding-documents/#finding-all-documents","text":"If you every want to find all documents you can use the find_all() classmethod. This is equivalent to find({}) .","title":"Finding all documents"},{"location":"tutorial/indexes-%26-collection-names/","text":"Indexes & collection names Although the basic pydantic syntax allows you to set all aspects of individual fields, there is also some need to configure collections as a whole. In particular you might want to: Set the MongoDB collection name Configure indexes This is done by defining a Collection class within your Document class. Declaring the collection name To set MongoDB collection name you can use the name field of the Collection inner class. class Sample ( Document ): num : int description : str class Collection : name = \"samples\" Indexes Indexed function To setup an index over a single field the Indexed function can be used to wrap the type and does not require a Collection class: from beanie import Indexed class Sample ( Document ): num : Indexed ( int ) description : str The Indexed function takes an optional argument index_type , which may be set to a pymongo index type: class Sample ( Document ): description : Indexed ( str , index_type = pymongo . TEXT ) The Indexed function also supports pymogo's IndexModel kwargs arguments (see the PyMongo Documentation for details). For example to create unique index: class Sample ( Document ): name : Indexed ( str , unique = True ) Multi-field indices The indexes field of the inner Collection class is responsible for more complex indexes. It is a list where items could be: single key. Name of the document's field (this is equivalent to using the Indexed function described above without any additional arguments) list of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction ( example: pymongo.ASCENDING ) pymongo.IndexModel instance - the most flexible option. PyMongo Documentation class DocumentTestModelWithIndex ( Document ): test_int : int test_list : List [ SubDocument ] test_str : str class Collection : indexes = [ \"test_int\" , [ ( \"test_int\" , pymongo . ASCENDING ), ( \"test_str\" , pymongo . DESCENDING ), ], IndexModel ( [( \"test_str\" , pymongo . DESCENDING )], name = \"test_string_index_DESCENDING\" , ), ]","title":"Indexes & collection names"},{"location":"tutorial/indexes-%26-collection-names/#indexes-collection-names","text":"Although the basic pydantic syntax allows you to set all aspects of individual fields, there is also some need to configure collections as a whole. In particular you might want to: Set the MongoDB collection name Configure indexes This is done by defining a Collection class within your Document class.","title":"Indexes &amp; collection names"},{"location":"tutorial/indexes-%26-collection-names/#declaring-the-collection-name","text":"To set MongoDB collection name you can use the name field of the Collection inner class. class Sample ( Document ): num : int description : str class Collection : name = \"samples\"","title":"Declaring the collection name"},{"location":"tutorial/indexes-%26-collection-names/#indexes","text":"","title":"Indexes"},{"location":"tutorial/indexes-%26-collection-names/#indexed-function","text":"To setup an index over a single field the Indexed function can be used to wrap the type and does not require a Collection class: from beanie import Indexed class Sample ( Document ): num : Indexed ( int ) description : str The Indexed function takes an optional argument index_type , which may be set to a pymongo index type: class Sample ( Document ): description : Indexed ( str , index_type = pymongo . TEXT ) The Indexed function also supports pymogo's IndexModel kwargs arguments (see the PyMongo Documentation for details). For example to create unique index: class Sample ( Document ): name : Indexed ( str , unique = True )","title":"Indexed function"},{"location":"tutorial/indexes-%26-collection-names/#multi-field-indices","text":"The indexes field of the inner Collection class is responsible for more complex indexes. It is a list where items could be: single key. Name of the document's field (this is equivalent to using the Indexed function described above without any additional arguments) list of (key, direction) pairs. Key - string, name of the document's field. Direction - pymongo direction ( example: pymongo.ASCENDING ) pymongo.IndexModel instance - the most flexible option. PyMongo Documentation class DocumentTestModelWithIndex ( Document ): test_int : int test_list : List [ SubDocument ] test_str : str class Collection : indexes = [ \"test_int\" , [ ( \"test_int\" , pymongo . ASCENDING ), ( \"test_str\" , pymongo . DESCENDING ), ], IndexModel ( [( \"test_str\" , pymongo . DESCENDING )], name = \"test_string_index_DESCENDING\" , ), ]","title":"Multi-field indices"},{"location":"tutorial/initialization/","text":"Beanie uses Motor as an async database engine. To init previously created documents, you should provide a Motor database instance and list of your document models to the init_beanie(...) function, as it is shown in the example: from beanie import init_beanie , Document import motor class Sample ( Document ): name : str async def init (): # Crete Motor client client = motor . motor_asyncio . AsyncIOMotorClient ( \"mongodb://user:pass@host:27017\" ) # Init beanie with the Product document class and a database await init_beanie ( database = client . db_name , document_models = [ Sample ]) This creates the collection (if needed) and sets up any indexes that are defined. init_beanie supports not only list of classes for the document_models parameter, but also strings with the dot separated paths: await init_beanie ( database = db , document_models = [ \"app.models.DemoDocument\" , ], )","title":"Initialization"},{"location":"tutorial/inserting-into-the-database/","text":"Insert the documents Beanie documents behave just like pydantic models (because they are pydantic models). Hence a document can be created in a similar fashion to pydantic: from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed class Category ( BaseModel ): name : str description : str class Product ( Document ): # This is the model name : str description : Optional [ str ] = None price : Indexed ( float ) category : Category class Collection : name = \"products\" chocolate = Category ( name = \"Chocolate\" , description = \"A preparation of roasted and ground cacao seeds.\" ) tonybar = Product ( name = \"Tony's\" , price = 5.95 , category = chocolate ) marsbar = Product ( name = \"Mars\" , price = 1 , category = chocolate ) This however does not save the documents to the database yet. Insert a single document To insert a document into the database, you can call either insert() or create() on it, the are synonyms: await tonybar . insert () await marsbar . create () # does exactly the same as insert() You can also call save() , which behaves the same for new documents, but will also update existing documents. See the section on updating of this tutorial for more details. If you prefer you can also call the insert_one classmethod: await Product . insert_one ( tonybar ) Inserting many documents To reduce the number of database queries, similarly typed documents should be inserted together by calling the classmethod insert_many . await Product . insert_many ([ tonybar , marsbar ])","title":"Inserting into the database"},{"location":"tutorial/inserting-into-the-database/#insert-the-documents","text":"Beanie documents behave just like pydantic models (because they are pydantic models). Hence a document can be created in a similar fashion to pydantic: from typing import Optional from pydantic import BaseModel from beanie import Document , Indexed class Category ( BaseModel ): name : str description : str class Product ( Document ): # This is the model name : str description : Optional [ str ] = None price : Indexed ( float ) category : Category class Collection : name = \"products\" chocolate = Category ( name = \"Chocolate\" , description = \"A preparation of roasted and ground cacao seeds.\" ) tonybar = Product ( name = \"Tony's\" , price = 5.95 , category = chocolate ) marsbar = Product ( name = \"Mars\" , price = 1 , category = chocolate ) This however does not save the documents to the database yet.","title":"Insert the documents"},{"location":"tutorial/inserting-into-the-database/#insert-a-single-document","text":"To insert a document into the database, you can call either insert() or create() on it, the are synonyms: await tonybar . insert () await marsbar . create () # does exactly the same as insert() You can also call save() , which behaves the same for new documents, but will also update existing documents. See the section on updating of this tutorial for more details. If you prefer you can also call the insert_one classmethod: await Product . insert_one ( tonybar )","title":"Insert a single document"},{"location":"tutorial/inserting-into-the-database/#inserting-many-documents","text":"To reduce the number of database queries, similarly typed documents should be inserted together by calling the classmethod insert_many . await Product . insert_many ([ tonybar , marsbar ])","title":"Inserting many documents"},{"location":"tutorial/migrations/","text":"Attention! Migrations use transactions inside. It works only with MongoDB replica sets Create To create a new migration run: beanie new-migration -n migration_name -p relative/path/to/migrations/directory/ It will create a file with the name *_migration_name.py in the directory relative/path/to/migrations/directory/ Migration file contains two classes: Forward and Backward . Each one contains instructions to roll migration respectively forward and backward. Run To roll one migration forward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1 To roll all the migrations forward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ To roll one migration backward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1 --backward To roll all the migrations backward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --backward To show help message with all the parameters and descriptions run beanie migrate --help Migration types Migration class contains instructions - decorated async functions. There are two types of instructions: Iterative migration - instruction, which iterates over all the documents of the input_document collection and updates it. Most comfortable to use. Can be used in 99% cases. Free fall migrations - instruction, where user can write any logic. Most flexible, but verbose. Iterative migrations To mark a function as iterative migration must be used decorator @iterative_migration() . The function itself as parameters must have input_document with type and output_document with type. Like here: @iterative_migration () async def name_to_title ( self , input_document : OldNote , output_document : Note ): A simple example of field name changing There are the next models: class Tag ( BaseModel ): color : str name : str class OldNote ( Document ): name : str tag : Tag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" To migrate from OldNote to Note filed name has to be renamed to title . Forward migration: class Forward : @iterative_migration () async def name_to_title ( self , input_document : OldNote , output_document : Note ): output_document . title = input_document . name Backward migration: class Backward : @iterative_migration () async def title_to_name ( self , input_document : Note , output_document : OldNote ): output_document . name = input_document . title And a little more complex example: from pydantic.main import BaseModel from beanie import Document , iterative_migration class OldTag ( BaseModel ): color : str name : str class Tag ( BaseModel ): color : str title : str class OldNote ( Document ): title : str tag : OldTag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" class Forward : @iterative_migration () async def change_color ( self , input_document : OldNote , output_document : Note ): output_document . tag . title = input_document . tag . name class Backward : @iterative_migration () async def change_title ( self , input_document : Note , output_document : OldNote ): output_document . tag . name = input_document . tag . title All the migrations examples can be found by link Free fall migrations It is a much more flexible migration type, which allows to implementation of any migration logic. But at the same time, it is more verbose. To mark function as a free fall migration, must be used decorator @free_fall_migration() with the list of Document classes, which will be used in this migration. Function itself receives session as a parameter. It is used to be able to roll back the migration, if something went wrong. To be able to roll back, please provide session into the Documents methods. Like here: @free_fall_migration ( document_models = [ OldNote , Note ]) async def name_to_title ( self , session ): async for old_note in OldNote . find_all (): new_note = Note ( id = old_note . id , title = old_note . name , tag = old_note . tag ) await new_note . replace ( session = session ) The same example as for the iterative migration, but with free fall migration type from pydantic.main import BaseModel from beanie import Document , free_fall_migration class Tag ( BaseModel ): color : str name : str class OldNote ( Document ): name : str tag : Tag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" class Forward : @free_fall_migration ( document_models = [ OldNote , Note ]) async def name_to_title ( self , session ): async for old_note in OldNote . find_all (): new_note = Note ( id = old_note . id , title = old_note . name , tag = old_note . tag ) await new_note . replace ( session = session ) class Backward : @free_fall_migration ( document_models = [ OldNote , Note ]) async def title_to_name ( self , session ): async for old_note in Note . find_all (): new_note = OldNote ( id = old_note . id , name = old_note . title , tag = old_note . tag ) await new_note . replace ( session = session ) All the migrations examples can be found by link","title":"Migrations"},{"location":"tutorial/migrations/#attention","text":"Migrations use transactions inside. It works only with MongoDB replica sets","title":"Attention!"},{"location":"tutorial/migrations/#create","text":"To create a new migration run: beanie new-migration -n migration_name -p relative/path/to/migrations/directory/ It will create a file with the name *_migration_name.py in the directory relative/path/to/migrations/directory/ Migration file contains two classes: Forward and Backward . Each one contains instructions to roll migration respectively forward and backward.","title":"Create"},{"location":"tutorial/migrations/#run","text":"To roll one migration forward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1 To roll all the migrations forward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ To roll one migration backward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --distance 1 --backward To roll all the migrations backward run: beanie migrate -uri 'mongodb+srv://user:pass@host/db' -p relative/path/to/migrations/directory/ --backward To show help message with all the parameters and descriptions run beanie migrate --help","title":"Run"},{"location":"tutorial/migrations/#migration-types","text":"Migration class contains instructions - decorated async functions. There are two types of instructions: Iterative migration - instruction, which iterates over all the documents of the input_document collection and updates it. Most comfortable to use. Can be used in 99% cases. Free fall migrations - instruction, where user can write any logic. Most flexible, but verbose.","title":"Migration types"},{"location":"tutorial/migrations/#iterative-migrations","text":"To mark a function as iterative migration must be used decorator @iterative_migration() . The function itself as parameters must have input_document with type and output_document with type. Like here: @iterative_migration () async def name_to_title ( self , input_document : OldNote , output_document : Note ):","title":"Iterative migrations"},{"location":"tutorial/migrations/#a-simple-example-of-field-name-changing","text":"There are the next models: class Tag ( BaseModel ): color : str name : str class OldNote ( Document ): name : str tag : Tag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" To migrate from OldNote to Note filed name has to be renamed to title . Forward migration: class Forward : @iterative_migration () async def name_to_title ( self , input_document : OldNote , output_document : Note ): output_document . title = input_document . name Backward migration: class Backward : @iterative_migration () async def title_to_name ( self , input_document : Note , output_document : OldNote ): output_document . name = input_document . title And a little more complex example: from pydantic.main import BaseModel from beanie import Document , iterative_migration class OldTag ( BaseModel ): color : str name : str class Tag ( BaseModel ): color : str title : str class OldNote ( Document ): title : str tag : OldTag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" class Forward : @iterative_migration () async def change_color ( self , input_document : OldNote , output_document : Note ): output_document . tag . title = input_document . tag . name class Backward : @iterative_migration () async def change_title ( self , input_document : Note , output_document : OldNote ): output_document . tag . name = input_document . tag . title All the migrations examples can be found by link","title":"A simple example of field name changing"},{"location":"tutorial/migrations/#free-fall-migrations","text":"It is a much more flexible migration type, which allows to implementation of any migration logic. But at the same time, it is more verbose. To mark function as a free fall migration, must be used decorator @free_fall_migration() with the list of Document classes, which will be used in this migration. Function itself receives session as a parameter. It is used to be able to roll back the migration, if something went wrong. To be able to roll back, please provide session into the Documents methods. Like here: @free_fall_migration ( document_models = [ OldNote , Note ]) async def name_to_title ( self , session ): async for old_note in OldNote . find_all (): new_note = Note ( id = old_note . id , title = old_note . name , tag = old_note . tag ) await new_note . replace ( session = session )","title":"Free fall migrations"},{"location":"tutorial/migrations/#the-same-example-as-for-the-iterative-migration-but-with-free-fall-migration-type","text":"from pydantic.main import BaseModel from beanie import Document , free_fall_migration class Tag ( BaseModel ): color : str name : str class OldNote ( Document ): name : str tag : Tag class Collection : name = \"notes\" class Note ( Document ): title : str tag : Tag class Collection : name = \"notes\" class Forward : @free_fall_migration ( document_models = [ OldNote , Note ]) async def name_to_title ( self , session ): async for old_note in OldNote . find_all (): new_note = Note ( id = old_note . id , title = old_note . name , tag = old_note . tag ) await new_note . replace ( session = session ) class Backward : @free_fall_migration ( document_models = [ OldNote , Note ]) async def title_to_name ( self , session ): async for old_note in Note . find_all (): new_note = OldNote ( id = old_note . id , name = old_note . title , tag = old_note . tag ) await new_note . replace ( session = session ) All the migrations examples can be found by link","title":"The same example as for the iterative migration, but with free fall migration type"},{"location":"tutorial/updating-%26-deleting/","text":"Updating & Deleting Now that we know how to find documents, how do we change them or delete them? Saving changes to existing documents The easiest way to change a document in the database is using either the replace or save methods on a altered document. These methods both write the document to the database, but replace will raise an exception when the document does not exist yet, while save will insert the document. Using save: bar = await Product . find_one ( Product . name == \"Mars\" ) bar . price = 10 await bar . save () Or similairly using replace, which trows a ValueError if the document does not have an id yet, or a beanie.exceptions.DocumentNotFound if it does but the id is not present in the collection: bar . price = 10 try : await bar . replace () except ( ValueError , beanie . exceptions . DocumentNotFound ): print ( \"Can't replace a non existing document\" ) Note however that these methods requires multiple queries to the database and replace the entire document with the new version. A more tailered solution can often be created by applying update queries directly on the database level. Update queries Update queries can be performed on the result of a find or find_one query, or on a document that was returned from an earlier query. Simpler updates can be performed using the set , inc , and current_date methods: bar = await Product . find_one ( Product . name == \"Mars\" ) await bar . set ({ Product . name : \"Gold bar\" }) bar = await Product . find_all ( Product . price > .5 ) . inc ({ Product . price : 1 }) More complex update operations can be performed by calling update() with a update operator, similair to find queries: await Product . find_one ( Product . name == \"Tony's\" ) . update ( Set ({ Product . price : 3.33 })) The whole list of the update query operators can be found here . Native MongoDB syntax is also accepted: await Product . find_one ( Product . name == \"Tony's\" ) . update ({ \"$set\" : { Product . price : 3.33 }}) Upsert To insert a document if no one document was matched the search criteria during the update query, the upsert method can be used: await Product . find_one ( Product . name == \"Tony's\" ) . upsert ( Set ({ Product . price : 3.33 }), on_insert = Product ( name = \"Tony's\" , price = 3.33 , category = chocolate ) ) Deleting documents Deleting objects works just like updating them, you simply call delete() : bar = await Product . find_one ( Product . name == \"Milka\" ) await bar . delete () await Product . find_one ( Product . name == \"Milka\" ) . delete () await Product . find ( Product . category . name == \"Chocolate\" ) . delete ()","title":"Updating & Deleting"},{"location":"tutorial/updating-%26-deleting/#updating-deleting","text":"Now that we know how to find documents, how do we change them or delete them?","title":"Updating &amp; Deleting"},{"location":"tutorial/updating-%26-deleting/#saving-changes-to-existing-documents","text":"The easiest way to change a document in the database is using either the replace or save methods on a altered document. These methods both write the document to the database, but replace will raise an exception when the document does not exist yet, while save will insert the document. Using save: bar = await Product . find_one ( Product . name == \"Mars\" ) bar . price = 10 await bar . save () Or similairly using replace, which trows a ValueError if the document does not have an id yet, or a beanie.exceptions.DocumentNotFound if it does but the id is not present in the collection: bar . price = 10 try : await bar . replace () except ( ValueError , beanie . exceptions . DocumentNotFound ): print ( \"Can't replace a non existing document\" ) Note however that these methods requires multiple queries to the database and replace the entire document with the new version. A more tailered solution can often be created by applying update queries directly on the database level.","title":"Saving changes to existing documents"},{"location":"tutorial/updating-%26-deleting/#update-queries","text":"Update queries can be performed on the result of a find or find_one query, or on a document that was returned from an earlier query. Simpler updates can be performed using the set , inc , and current_date methods: bar = await Product . find_one ( Product . name == \"Mars\" ) await bar . set ({ Product . name : \"Gold bar\" }) bar = await Product . find_all ( Product . price > .5 ) . inc ({ Product . price : 1 }) More complex update operations can be performed by calling update() with a update operator, similair to find queries: await Product . find_one ( Product . name == \"Tony's\" ) . update ( Set ({ Product . price : 3.33 })) The whole list of the update query operators can be found here . Native MongoDB syntax is also accepted: await Product . find_one ( Product . name == \"Tony's\" ) . update ({ \"$set\" : { Product . price : 3.33 }})","title":"Update queries"},{"location":"tutorial/updating-%26-deleting/#upsert","text":"To insert a document if no one document was matched the search criteria during the update query, the upsert method can be used: await Product . find_one ( Product . name == \"Tony's\" ) . upsert ( Set ({ Product . price : 3.33 }), on_insert = Product ( name = \"Tony's\" , price = 3.33 , category = chocolate ) )","title":"Upsert"},{"location":"tutorial/updating-%26-deleting/#deleting-documents","text":"Deleting objects works just like updating them, you simply call delete() : bar = await Product . find_one ( Product . name == \"Milka\" ) await bar . delete () await Product . find_one ( Product . name == \"Milka\" ) . delete () await Product . find ( Product . category . name == \"Chocolate\" ) . delete ()","title":"Deleting documents"}]}